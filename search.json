[{"path":"/AGENTS.html","id":"package-overview","dir":"","previous_headings":"","what":"Package Overview","title":"NA","text":"anvil code transformation framework similar jax R. currently support jit compilation automatic differentiation.","code":""},{"path":[]},{"path":"/AGENTS.html","id":"build-and-install","dir":"","previous_headings":"Development Commands","what":"Build and Install","title":"NA","text":"","code":"# Load the package for development devtools::load_all()  # Install the package devtools::install()  # Build the package (creates tar.gz file) devtools::build()"},{"path":"/AGENTS.html","id":"testing","dir":"","previous_headings":"Development Commands","what":"Testing","title":"NA","text":"","code":"# Run all tests devtools::test()  # Run a specific test file testthat::test_file(\"tests/testthat/test-constant.R\")"},{"path":"/AGENTS.html","id":"testing-guidelines","dir":"","previous_headings":"Development Commands","what":"Testing Guidelines","title":"NA","text":"rule primitive tested. Many tests can implemented comparing corresponding torch function (inst/extra-tests/test-primitives-stablehlo-torch.R inst/extra-tests/test-primitives-backward-torch.R, …). sourced test-primitives-stablehlo.R test-primitives-backward.R, etc.. Implement test comparing torch, possible necessary. test simple, functionality covered torch, implement test manually. Implement either torch test manual test, .","code":""},{"path":"/AGENTS.html","id":"documentation","dir":"","previous_headings":"Development Commands","what":"Documentation","title":"NA","text":"","code":"# Generate documentation from roxygen comments devtools::document()"},{"path":"/AGENTS.html","id":"check","dir":"","previous_headings":"Development Commands","what":"Check","title":"NA","text":"","code":"# Run checks for CRAN compliance devtools::check()"},{"path":"/AGENTS.html","id":"development-practices","dir":"","previous_headings":"","what":"Development Practices","title":"NA","text":"Use S7 (object-oriented system) defining types classes. Follow established pattern adding new operations types Add tests tests/testthat/ Document functions roxygen2 comments","code":""},{"path":"/AGENTS.html","id":"project-information","dir":"","previous_headings":"","what":"Project Information","title":"NA","text":"stablehlo (jit interpretation rules) uses 0-based indexing, anvil uses 1-based indexing. implementing jit interpretation rule, convert indices subtracting 1. rules-pullback.R file contains differentiation rules primitive operations. , grad gradient terminal output respect function’s output function return gradient terminal output respect inputs. tests file insts/extra-tests/test-primitives-pullback-torch.R","code":""},{"path":"/AGENTS.html","id":"style","dir":"","previous_headings":"","what":"Style","title":"NA","text":"length-1 vectors, don’t use c(). example, use 1L instead c(1L).","code":""},{"path":[]},{"path":"/AGENTS.html","id":"adding-a-primitive","dir":"","previous_headings":"","what":"Adding a Primitive","title":"NA","text":"functions prefixed nvl_ primitives defined primitives.R. implementing primitive, make sure inference function propagates ambiguity inputs output. Also, check whether stablehlo package corresponding inference function can wrapped. Pay attention stablehlo uses 0-based indexing, anvil uses 1-based indexing.","code":""},{"path":"/AGENTS.html","id":"adding-an-api-function","dir":"","previous_headings":"","what":"Adding an API function","title":"NA","text":"API functions prefixed nv_ defined files like api.R api-rng.R. Often, wrap primitives, make convenient use. accessing properties tensorish values, use shape_abstract, ndims_abstract, dtype_abstract. accessors currently available.","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 anvil authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/anvil.html","id":"the-anviltensor","dir":"Articles","previous_headings":"","what":"The AnvilTensor","title":"Get Started","text":"start introducing main data structure, AnvilTensor. essentially like R array, differences: supports data types, different precisions, well unsigned integers. tensor can live different devices, CPU GPU. 0-dimensional tensors can used represent scalars. can create AnvilTensor R objects using nv_tensor. , create 0-dimensional tensor (.e., scalar) holds 16-bit integer CPU. Note creation scalars, can also use nv_scalar shorthand skip specifying shape omit specifying device, CPU default. can also create higher-dimensional tensors, example 2x3 tensor single-precision floating-point numbers. Without specifying data type, default \"f32\" R doubles \"i32\" integers. as_array() function allows convert AnvilTensors back R objects. Note 0-dimensional tensors, result R vector length 1, R arrays 0 dimensions. first, working AnvilTensors may feel bit cumbersome, directly apply functions like regular R arrays.","code":"library(anvil) set.seed(42) nv_tensor(1L, dtype = \"i16\", device = \"cpu\", shape = integer()) ## AnvilTensor  ##  1 ## [ CPUi16{} ] nv_scalar(1L, dtype = \"i16\") ## AnvilTensor  ##  1 ## [ CPUi16{} ] x <- array(1:6, dim = c(2, 3)) y <- nv_tensor(x) y ## AnvilTensor  ##  1 3 5 ##  2 4 6 ## [ CPUi32{2x3} ] as_array(y) ##      [,1] [,2] [,3] ## [1,]    1    3    5 ## [2,]    2    4    6 x + x ##      [,1] [,2] [,3] ## [1,]    2    6   10 ## [2,]    4    8   12 y + y ## i32{2,3}"},{"path":"/articles/anvil.html","id":"jit-compilation","dir":"Articles","previous_headings":"","what":"JIT Compilation","title":"Get Started","text":"order work AnvilTensors, need convert function want apply jit-compiled version via jit(). result operation AnvilTensor. can also jit-compile complex functions. , define function takes data matrix X, weight vector beta, scalar bias alpha, computes linear model output \\(y = X \\times \\beta + \\alpha\\). One restriction {anvil} function re-compiled every unique combination input types, consisting specific shape data type. demonstrate , create slightly modified version previous linear predictor function: Next, create little helper function creates example inputs different numbers observations: , call function twice data shapes. can notice see \"compiling ...\" message first time, function first compiled XLA executable, cached, executed. second time, executable retrieved cache (inputs shapes data types) executed without recompilation. executable contains operations applied AnvilTensors, contain cat() call, don’t see second time. call function data different shapes (data types), function re-compiled message re-appears. compilation step can take time, {anvil} therefore gives best results function called many times (different) input types, computation sufficiently large amortize compilation overhead.","code":"plus_jit <- jit(`+`) plus_jit(y, y) ## AnvilTensor  ##   2  6 10 ##   4  8 12 ## [ CPUi32{2x3} ] linear_model_r <- function(X, beta, alpha) {   X %*% beta + alpha }  linear_model <- jit(linear_model_r)  X <- nv_tensor(rnorm(6), dtype = \"f32\", shape = c(2, 3)) beta <- nv_tensor(rnorm(3), dtype = \"f32\", shape = c(3, 1)) alpha <- nv_scalar(rnorm(1), dtype = \"f32\")  linear_model(X, beta, alpha) ## AnvilTensor  ##   2.7911 ##  -1.1904 ## [ CPUf32{2x1} ] linear_model2 <- jit(function(X, beta, alpha) {   cat(\"compiling ...\\n\")   X %*% beta + alpha }) simul_data <- function(n, p) {   list(     X = nv_tensor(rnorm(n * p), dtype = \"f32\", shape = c(n, p)),     beta = nv_tensor(rnorm(p), dtype = \"f32\", shape = c(p, 1)),     alpha = nv_scalar(rnorm(1), dtype = \"f32\")   ) } do.call(linear_model2, simul_data(2, 3)) ## compiling ... ## AnvilTensor  ##   4.9640 ##  -0.1413 ## [ CPUf32{2x1} ] do.call(linear_model2, simul_data(2, 3)) ## AnvilTensor  ##   0.6140 ##  -2.5214 ## [ CPUf32{2x1} ] y_hat <- do.call(linear_model2, simul_data(4, 3)) ## compiling ..."},{"path":"/articles/anvil.html","id":"static-arguments","dir":"Articles","previous_headings":"JIT Compilation","what":"Static Arguments","title":"Get Started","text":"Besides AnvilTensors, jit-compiled functions can also take regular R values arguments. example, might want linear model without bias term. , add logical(1) argument with_bias function. need mark argument static, {anvil} knows treat regular R value. can now call function without bias term: Static arguments work differently AnvilTensors function re-compiled new observed value static argument, unique input type combination.","code":"linear_model3 <- jit(function(X, beta, alpha = NULL, with_bias) {   if (with_bias) {     cat(\"Compiling with bias ...\\n\")     X %*% beta + alpha   } else {     cat(\"Compiling without bias ...\\n\")     X %*% beta   } }, static = \"with_bias\") linear_model3(X, beta, with_bias = FALSE) ## Compiling without bias ... ## AnvilTensor  ##   2.8538 ##  -1.1277 ## [ CPUf32{2x1} ] linear_model3(X, beta, alpha, with_bias = TRUE) ## Compiling with bias ... ## AnvilTensor  ##   2.7911 ##  -1.1904 ## [ CPUf32{2x1} ]"},{"path":"/articles/anvil.html","id":"nested-inputs-and-outputs","dir":"Articles","previous_headings":"JIT Compilation","what":"Nested Inputs and Outputs","title":"Get Started","text":"Inputs outputs can also nested data structures contain AnvilTensors, although currently support (named) lists. far, implemented prediction step linear model. One core applications {anvil} implement learning algorithms, often need gradients, well control flow. start gradients.","code":"linear_model4 <- jit(function(inputs) {   list(y_hat = inputs[[1]] %*% inputs[[2]] + inputs[[3]]) }) linear_model4(list(X, beta, alpha)) ## $y_hat ## AnvilTensor  ##   2.7911 ##  -1.1904 ## [ CPUf32{2x1} ]"},{"path":"/articles/anvil.html","id":"automatic-differentiation","dir":"Articles","previous_headings":"","what":"Automatic Differentiation","title":"Get Started","text":"{anvil}, can easily obtain gradient function scalar-valued function via gradient(). Currently, don’t support jacobians hessians, hopefilly added future. , implement loss function linear model. now need target variables y, simulate data linear model:  Next, randomly initialize model parameters: can now define function prediction calculates loss. Note calling original R function prediction jit-compiled version. Using gradient() transformation, can automatically obtain gradient function model_loss respect arguments, specify. Finally, define update step weights using gradient descent. already allows us fit linear model  might seem like reasonable solution, continuously switches R interpreter XLA runtime. Moreover, allocate new tensors iteration weights. latter might big problem small models, can cause significant overhead working bigger tensors. Next, discuss control flow {anvil} address immutability.","code":"mse <- function(y_hat, y) {   mean((y_hat - y)^2.0) } beta <- rnorm(1) X <- matrix(rnorm(100), ncol = 1) alpha <- rnorm(1) y <- X %*% beta + alpha + rnorm(100, sd = 0.5) plot(X, y) X <- nv_tensor(X) y <- nv_tensor(y) beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\") model_loss <- function(X, beta, alpha, y) {   y_hat <- linear_model_r(X, beta, alpha)   mse(y_hat, y) } model_loss_grad <- gradient(   model_loss,   wrt = c(\"beta\", \"alpha\") ) update_weights_r <- function(X, beta, alpha, y) {   lr <- 0.1   grads <- model_loss_grad(X, beta, alpha, y)   beta_new <- beta - lr * grads$beta   alpha_new <- alpha - lr * grads$alpha   list(beta = beta_new, alpha = alpha_new) } update_weights <- jit(update_weights_r) weights <- list(beta = beta_hat, alpha = alpha_hat) for (i in 1:100) {   weights <- update_weights(X, weights$beta, weights$alpha, y) }"},{"path":"/articles/anvil.html","id":"control-flow","dir":"Articles","previous_headings":"","what":"Control Flow","title":"Get Started","text":"principle, three ways implement control-flow {anvil}: Embed jit-compiled functions inside R control-flow constructs, seen earlier. Embed R control flow inside jit-compiled function (also seen earlier linear model allowed optionally include bias term). Use special control-flow primitives provided anvil, nv_while() nv_if(). solution best depends specific scenario, cover three cases, risk bit repetitive. illustrate linear model training example earlier. first implementation already seen earlier: jit-compile update step repeatedly call R loop: simple update steps, solution can inefficient every call jit-compiled function overhead. significant overhead depends expensive call loop – expensive functions overhead becomes negligible. second approach use R loop within jit-compiled function. , loop unrolled compilation step (conditionals, one branch included executable discussed earlier). rather slow example hand, also re-compute gradient function iteration. Moreover, parameter n_steps static, means every unique value n_steps, function re-compiled different executable. Finally, third approach use nv_while function. like standard loop, anvil purely functional. function takes : initial state, (nested) list AnvilTensors. cond function, takes input current state returns logical flag indicating whether continue loop. body function, takes input current state returns new state. approach works analogously -statements, {anvil} primitive nv_if available.","code":"n_steps <- 100L beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\")  weights <- list(beta = beta_hat, alpha = alpha_hat) for (i in seq_len(n_steps)) {   weights <- update_weights(X, weights$beta, weights$alpha, y) } weights ## $beta ## AnvilTensor  ##  -0.9184 ## [ CPUf32{1x1} ]  ##  ## $alpha ## AnvilTensor  ##  -0.4376 ## [ CPUf32{} ] train_unrolled <- jit(function(X, beta, alpha, y, n_steps) {   lr <- nv_scalar(0.1)   for (i in seq_len(n_steps)) {     grads <- model_loss_grad(X, beta, alpha, y)     beta <- beta - lr * grads$beta     alpha <- alpha - lr * grads$alpha   }   list(beta = beta, alpha = alpha) }, static = \"n_steps\")  beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\") train_unrolled(X, beta_hat, alpha_hat, y, n_steps = 10L) ## $beta ## AnvilTensor  ##  -0.9600 ## [ CPUf32{1x1} ]  ##  ## $alpha ## AnvilTensor  ##  -0.3703 ## [ CPUf32{} ] train_while <- jit(function(X, beta, alpha, y, n_steps) {   lr <- 0.1   nv_while(     list(beta = beta, alpha = alpha, i = nv_scalar(0L)),     \\(beta, alpha, i) i < n_steps,     \\(beta, alpha, i) {       grads <- model_loss_grad(X, beta, alpha, y)       list(         beta = beta - lr * grads$beta,         alpha = alpha - lr * grads$alpha,         i = i + 1L       )     }   ) })  beta_hat <- nv_tensor(rnorm(1), shape = c(1, 1), dtype = \"f32\") alpha_hat <- nv_scalar(rnorm(1), dtype = \"f32\") train_while(X, beta_hat, alpha_hat, y, nv_scalar(100L)) ## $beta ## AnvilTensor  ##  -0.9184 ## [ CPUf32{1x1} ]  ##  ## $alpha ## AnvilTensor  ##  -0.4376 ## [ CPUf32{} ]  ##  ## $i ## AnvilTensor  ##  100 ## [ CPUi32{} ]"},{"path":"/articles/anvil.html","id":"immutability","dir":"Articles","previous_headings":"","what":"Immutability","title":"Get Started","text":"AnvilTensor objects immutable, .e., created, value changed. words, conceptually -place updates like x[1] <- x[1] + 1. means {anvil} follows value semantics, .e., functions pure. Naturally, raises question impacts performance. need distinguish two scenarios: Updating AnvilTensor “lives within” jit-compiled function. Updating AnvilTensor “living R” jit-compiled function. first scenario, nothing worry . XLA compiler able optimize , ensuring unnecessary copies actually made. similar copy--write semantics R. evaluate x <- 1:10; y <- x, conceptually creating copy x assigning y, internally, optimized away copy created modifying y x. {anvil} uses compilation shapes known compile time, can make many optimizations, minimizing unnecessary copies much possible. However, also case one calls {anvil} function R code, done initial linear model example. assignment outputs {anvil} function R variables happen within executable, XLA compiler optimize . know inputs {anvil} function needed anymore function call (case “update-calls” like ), can mark “donatable” jit-compiling. tell XLA compiler longer need inputs alpha beta afterwards, underlying memory can reused. now print input weights, get error tensors deleted. new weights still .","code":"weights <- update_weights(X, weights$beta, weights$alpha, y) update_weights_donatable <- jit(update_weights_r, donate = c(\"beta\", \"alpha\")) weights_out <- update_weights_donatable(X, weights$beta, weights$alpha, y) weights ## $beta ## AnvilTensor ## Error: ## ! ToLiteral() called on deleted or donated buffer: INVALID_ARGUMENT: Buffer has been deleted or donated. weights_out ## $beta ## AnvilTensor  ##  -0.9184 ## [ CPUf32{1x1} ]  ##  ## $alpha ## AnvilTensor  ##  -0.4376 ## [ CPUf32{} ]"},{"path":"/articles/debugging.html","id":"debug-mode","dir":"Articles","previous_headings":"","what":"Debug Mode","title":"Debugging","text":"{anvil} functions executed without wrapped jit(), run debug mode output DebugBox object, essentially represents type output tensor. use debug mode, can pass AnvilTensor literals (1L, 1.0). want specify abstract types, can also directly pass DebugBox objects: can even evaluate transformations like gradients debug mode: happens R interpreter, can also add breakpoints code step identify bugs. However, even program valid can compiled, might work expected, e.g. logical bugs invalid hyperparameters. , ’s important monitor (intermediate) values, cover next section.","code":"library(anvil) y <- nv_scalar(1) + nv_tensor(1:4, shape = c(2, 2)) y ## f32{2,2} mean(y) ## f32{} 1 + nv_scalar(1) ## f32{} debug_box(\"f32\", c(2, 3)) %*% debug_box(\"f32\", c(3, 1)) ## f32{2,1} gradient(mean)(debug_box(\"f32\", c(2, 2))) ## $x ## f32{2,2}"},{"path":"/articles/debugging.html","id":"printing-values","dir":"Articles","previous_headings":"","what":"Printing Values","title":"Debugging","text":"different ways print values {anvil} might confusing first. start naive way simply inserting print() statements code jit-compiled function. run function, see actual value printed, GraphBox object. GraphBox object passed around tracing can convert function Graph subsequently compiled. Furthermore, call function identical input types, won’t printed executable retrieved cache. want get actual content values execution, two options: Ensure value print returned jit-compiled function can printed execution. comes naturally jit-compiled function called within R loop. Using special nv_print() function print execution. useful value print naturally returned function. illustrative purposes, count 10 print intermediate results. first approach, jit-compile update function iteratively call R loop. second approach, use nv_while implement loop. provide formatting options future!","code":"f_jit <- jit(\\(x) {   y <- x^2 + x^2   print(y)   mean(y) }) f_jit(nv_tensor(1:4, shape = c(2, 2))) ## GraphBox(GraphValue(AbstractTensor(dtype=f32?, shape=2x2))) ## AnvilTensor  ##  15.0000 ## [ CPUf32{} ] f_jit(nv_tensor(0:3, shape = c(2, 2))) ## AnvilTensor  ##  7.0000 ## [ CPUf32{} ] add_one <- jit(\\(x) x + 1L) x <- nv_scalar(0L) for (i in 1:10) {   x <- add_one(x)   print(x) } ## AnvilTensor  ##  1 ## [ CPUi32{} ]  ## AnvilTensor  ##  2 ## [ CPUi32{} ]  ## AnvilTensor  ##  3 ## [ CPUi32{} ]  ## AnvilTensor  ##  4 ## [ CPUi32{} ]  ## AnvilTensor  ##  5 ## [ CPUi32{} ]  ## AnvilTensor  ##  6 ## [ CPUi32{} ]  ## AnvilTensor  ##  7 ## [ CPUi32{} ]  ## AnvilTensor  ##  8 ## [ CPUi32{} ]  ## AnvilTensor  ##  9 ## [ CPUi32{} ]  ## AnvilTensor  ##  10 ## [ CPUi32{} ] jit(\\() {   init <- nv_fill(1L, shape = c())   nv_while(     list(x = init),     \\(x) x <= 10,     \\(x) {       nv_print(x)       list(x = x + 1L)     }   ) }, device = \"cpu\")() ## AnvilTensor ##  1 ## [ S32{} ] ## AnvilTensor ##  2 ## [ S32{} ] ## AnvilTensor ##  3 ## [ S32{} ] ## AnvilTensor ##  4 ## [ S32{} ] ## AnvilTensor ##  5 ## [ S32{} ] ## AnvilTensor ##  6 ## [ S32{} ] ## AnvilTensor ##  7 ## [ S32{} ] ## AnvilTensor ##  8 ## [ S32{} ] ## AnvilTensor ##  9 ## [ S32{} ] ## AnvilTensor ##  10 ## [ S32{} ] ## $x ## AnvilTensor  ##  11 ## [ CPUi32{} ]"},{"path":"/articles/internals.html","id":"transforming-code","dir":"Articles","previous_headings":"","what":"Transforming Code","title":"Internals","text":"real anvil made reshaping metal, package tool reshaping code. refer rewriting code transformation, three types: R \\(\\rightarrow\\) Graph: Generic R functions complicated handle, first step {anvil} always convert computational anvil::Graph object via tracing. Graph similar JAXExpr objects JAX. operates AnvilTensor objects applies anvil::Primitive operations . Graph \\(\\rightarrow\\) Graph: possible transform Graphs Graphs. purpose change functionality code. time writing, essentially one transformation, namely backward-mode automatic differentiation via gradient(). Graph \\(\\rightarrow\\) Executable: order perform actual computation, Graph needs converted executable. Currently, support XLA backend (via stablehlo pjrt), working experimental quickr backend.","code":""},{"path":"/articles/internals.html","id":"tracing-r-functions-into-graphs","dir":"Articles","previous_headings":"Transforming Code","what":"Tracing R Functions into Graphs","title":"Internals","text":"functionality {anvil} package centered around anvil::Graph class. principle possible create Graphs hand, usually created tracing R functions. general, want convert code another form (case, R Code Graph), two approaches: Static analysis, require operating abstract syntax tree (AST) code. Dynamic analysis (aka “tracing”), executes code records selected operations. former approach followed {quickr} package, go tracing. start simple, yet illustrative example either adds multiplies two inputs x y depending value op. , use anvil::trace_fn(), takes R function list AbstractTensor inputs specify types inputs. output trace_fn() now Graph object represents computation. fields Graph : inputs, GraphNodes represent inputs function. outputs, GraphNodes represent outputs function. calls, PrimitiveCalls take GraphNodes (parameters) produce output GraphNodes. in_tree, out_tree, cover later (??) trace_fn, inputs happens trace_fn() new GraphDescriptor created inputs x y converted anvil::GraphBox objects. , function f simply evaluated GraphBox objects inputs. evaluation, need distinguish two cases: “standard” R function called: , nothing special happens function simply evaluated. anvil function called: , operation underlies function recorded GraphDescriptor. evaluation statement example first category. set op = \"mul\", first branch executed. , calling nv_mul, attaches PrimitiveCall represents multiplication two tensors @calls GraphDescriptor. Note nv_mul primitive, performs type promotion broadcasting needed, calling primitive nvl_mul(). PrimitiveCall object consists following fields: primitive: primitive function called. inputs: inputs primitive function. params: parameters (non-tensors) primitive function. outputs: outputs primitive function. evaluation f complete, @outputs field GraphDescriptor set Graph subsequently created GraphDescriptor. difference Graph GraphDescriptor latter utility fields useful graph creation, purposes tutorial, can think .","code":"library(anvil) f <- function(x, y, op) {   if (op == \"add\") {     nv_add(x, y)   } else if (op == \"mul\") {     nv_mul(x, y)   } else {     stop(\"Unsupported operation\")   } } aten <- nv_aten(\"f32\", c()) aten ## AbstractTensor(dtype=f32, shape=) graph <- trace_fn(f, list(x = aten, y = aten, op = \"mul\")) graph ## <Graph> ##   Inputs: ##     %x1: f32[] ##     %x2: f32[] ##   Body: ##     %1: f32[] = mul(%x1, %x2) ##   Outputs: ##     %1: f32[]"},{"path":"/articles/internals.html","id":"transforming-graphs-into-other-graphs","dir":"Articles","previous_headings":"Transforming Code","what":"Transforming Graphs into other Graphs","title":"Internals","text":"R function staged simpler format, ready transformed. {anvil} package way dictate Graph Graph transformation can implemented. interesting transformations, however, need store information {anvil} primitive function. case gradient, need store derivative rules. , anvil::Primitive objects @rules field can populated. derivative rules stored functions \"backward\" name. can access primitive ’s name via prim() function: anvil::transform_gradient function uses rules compute gradient function. specific transformation, walking graph backwards apply derivative rules, append “backward pass” graph. Besides forward graph, transformation takes wrt argument, specifies respect arguments compute gradient.","code":"prim(\"mul\")@rules[[\"backward\"]] ## function (inputs, outputs, grads, .required)  ## { ##     lhs <- inputs[[1L]] ##     rhs <- inputs[[2L]] ##     grad <- grads[[1L]] ##     list(if (.required[[1L]]) nvl_mul(grad, rhs), if (.required[[2L]]) nvl_mul(grad,  ##         lhs)) ## } ## <bytecode: 0x5620158bb390> ## <environment: namespace:anvil> bwd_graph <- transform_gradient(graph, wrt = c(\"x\", \"y\")) bwd_graph ## <Graph> ##   Inputs: ##     %x1: f32[] ##     %x2: f32[] ##   Constants: ##     %c1: f32[] ##   Body: ##     %1: f32[] = mul(%x1, %x2) ##     %2: f32[] = mul(%c1, %x2) ##     %3: f32[] = mul(%c1, %x1) ##   Outputs: ##     %2: f32[] ##     %3: f32[]"},{"path":"/articles/internals.html","id":"lowering-a-graph","dir":"Articles","previous_headings":"Transforming Code","what":"Lowering a Graph","title":"Internals","text":"order execute Graph, need convert – wait – executable. , compile using XLA backend. First, translate Graph StableHLO representation via {stablehlo} package. , compile program using XLA compiler accessible via {pjrt} package. Like gradient transformation, rules transformation stored @rules fields primitives. anvil::stablehlo function create stablehlo::Func object sequentially translate PrimitiveCalls StableHLO operations. Now, can compile function via pjrt_compile(). run function, simply pass tensors executable, output PJRTBuffer can easily convert AnvilTensor.","code":"prim(\"mul\")@rules[[\"stablehlo\"]] ## function (lhs, rhs)  ## { ##     list(stablehlo::hlo_multiply(lhs, rhs)) ## } ## <bytecode: 0x5620158be318> ## <environment: namespace:anvil> func <- stablehlo(graph)[[1L]] func ## func.func @main (%0: tensor<f32>, %1: tensor<f32>) -> tensor<f32> { ## %2 = \"stablehlo.multiply\" (%0, %1): (tensor<f32>, tensor<f32>) -> (tensor<f32>) ## \"func.return\"(%2): (tensor<f32>) -> () ## } hlo_str <- stablehlo::repr(func) program <- pjrt::pjrt_program(src = hlo_str, format = \"mlir\") exec <- pjrt::pjrt_compile(program) x <- nv_scalar(3, \"f32\") y <- nv_scalar(4, \"f32\") out <- pjrt::pjrt_execute(exec, x, y) out ## PJRTBuffer  ##  12.0000 ## [ CPUf32{} ] nv_tensor(out) ## AnvilTensor  ##  12.0000 ## [ CPUf32{} ]"},{"path":"/articles/internals.html","id":"the-user-interface","dir":"Articles","previous_headings":"","what":"The User Interface","title":"Internals","text":"previous section, shown transformations implemented hood. actual user interface little convenient follows JAX interface.","code":""},{"path":"/articles/internals.html","id":"jit","dir":"Articles","previous_headings":"The User Interface","what":"jit()","title":"Internals","text":"jit() function allows convert regular R function Just--Time compiled function can executed AnvilTensors. apply simple example function, mark non-tensor parameter op “static”. means value parameter needs known compile time. One might think jit() first calls trace_fn(), runs stablehlo(), followed pjrt_compile(). , however, happening, requires input types known. Instead, f_jit “lazy” function perform steps inputs provided. However, steps applied every time f_jit function called, inefficient, tracing compiling takes time. Therefore, function f_jit also contains cache (implemented xlamisc::LRUCache), check whether already compiled executable given inputs. , types AnvilTensors need match exactly (data type shape) static arguments need identical. example, run function AnvilTensors type, different values, function won’t recompiled, can see checking size cache, already 1, called x y . calling tensors types identical static argument values, size cache remains 1: execute function tensors different dtype shape, function recompiled: Also, provide different values static arguments, function recompiled:","code":"f_jit <-  jit(f, static = \"op\") f_jit(x, y, \"add\") ## AnvilTensor  ##  7.0000 ## [ CPUf32{} ] cache_size <- function(f) environment(f)$cache$size cache_size(f_jit) ## [1] 1 f_jit(nv_scalar(-99, \"f32\"), nv_scalar(2, \"f32\"), \"add\") ## AnvilTensor  ##  -97.0000 ## [ CPUf32{} ] cache_size(f_jit) ## [1] 1 f_jit(nv_scalar(1, \"i32\"), nv_scalar(2, \"i32\"), \"add\") ## AnvilTensor  ##  3 ## [ CPUi32{} ] cache_size(f_jit) ## [1] 2 f_jit(nv_scalar(1, \"f32\"), nv_scalar(2, \"f32\"), \"mul\") ## AnvilTensor  ##  2.0000 ## [ CPUf32{} ] cache_size(f_jit) ## [1] 3"},{"path":"/articles/internals.html","id":"gradient","dir":"Articles","previous_headings":"The User Interface","what":"gradient()","title":"Internals","text":"Just like jit(), gradient() also returns function lazily create graph transform , inputs provided. Calling g() AnvilTensors actually compute gradient, instead just output output types, c.f. debugging vignette . want actually compute gradient, need wrap jit(). Moreover, can also use g another function: , happening ? inputs x y provided h_jit, new GraphDescriptor created inputs x y converted GraphBox objects. , addition x y recorded GraphDescriptor. call g() bit involved. First, new GraphDescriptor created forward computation g recorded. Subsequently, backward pass added descriptor, converted Graph. Graph inlined parent GraphDescriptor (representing whole function h), converted main Graph. can look graph , trace_fn internally converts AnvilTensors x y abstract representation. Afterwards, graph lowered stableHLO subsequently compiled.","code":"g <- gradient(f, wrt = c(\"x\", \"y\")) g(x, y, \"add\") ## $x ##  1.0000 ## [ CPUf32{} ]  ##  ## $y ##  1.0000 ## [ CPUf32{} ] g_jit <- jit(g, static = \"op\") g_jit(x, y, \"add\") ## $x ## AnvilTensor  ##  1.0000 ## [ CPUf32{} ]  ##  ## $y ## AnvilTensor  ##  1.0000 ## [ CPUf32{} ] h <- function(x, y) {   z <- nv_add(x, y)   g(z, x, \"mul\") } h_jit <- jit(h) h_jit(x, y) ## $x ## AnvilTensor  ##  3.0000 ## [ CPUf32{} ]  ##  ## $y ## AnvilTensor  ##  7.0000 ## [ CPUf32{} ] h_graph <- trace_fn(h, list(x = x, y = y)) h_graph ## <Graph> ##   Inputs: ##     %x1: f32[] ##     %x2: f32[] ##   Constants: ##     %c1: f32[] ##   Body: ##     %1: f32[] = add(%x1, %x2) ##     %2: f32[] = mul(%1, %x1) ##     %3: f32[] = mul(%c1, %x1) ##     %4: f32[] = mul(%c1, %1) ##   Outputs: ##     %3: f32[] ##     %4: f32[]"},{"path":[]},{"path":"/articles/internals.html","id":"debug-mode","dir":"Articles","previous_headings":"More Internals","what":"Debug Mode","title":"Internals","text":"use debug mode, see debugging vignette. Debug-mode different jit-mode, don’t context can initialize main GraphDescriptor. reason, every primitive initializes GraphDescriptor thrown away primitive returns DebugBox objects. DebugBox objects user-interaction nice printer. Whenever primitive evaluated, DebugBox converted GraphBox object used actual evaluation via maybe_box_variable. ensures don’t duplicate evaluation logic graph-building functions work GraphBox objects. gets lost debug mode identity values, GraphDescriptor thrown away. means say anything identity values, types. Unfortunately, current mode detecting debug mode whether GraphDescriptor active. reason, don’t allow calling local_descriptor() global environment. Maybe can improve future, now seems work.","code":""},{"path":[]},{"path":[]},{"path":"/articles/random-numbers.html","id":"the-rng-state","dir":"Articles","previous_headings":"","what":"The RNG State","title":"Random Number Generation","text":"base R, random number generation uses global state (.Random.seed) automatically updated call: {anvil}, take different approach: random number generator state must explicitly passed around. {anvil} follows functional programming paradigm functions pure don’t side effects. Note: explicit state-passing behavior might change future provide R-like experience, now need manage state .","code":"set.seed(42) .Random.seed[2:4] #> [1]        624  507561766 1260545903 rnorm(3) #> [1]  1.3709584 -0.5646982  0.3631284 .Random.seed[2:4] #> [1]           6 -1577024373  1699409082 rnorm(3) #> [1]  0.6328626  0.4042683 -0.1061245 .Random.seed[2:4] #> [1]          12 -1577024373  1699409082"},{"path":"/articles/random-numbers.html","id":"creating-an-initial-state","dir":"Articles","previous_headings":"","what":"Creating an Initial State","title":"Random Number Generation","text":"generate random numbers, first need create initial RNG state, simply ui64[2]. convenience, can convert R seed state using nv_rng_state():","code":"library(anvil) state <- nv_rng_state(seed = 42L) state #> AnvilTensor  #>  42 #>   0 #> [ CPUui64{2} ]"},{"path":"/articles/random-numbers.html","id":"generating-random-numbers","dir":"Articles","previous_headings":"","what":"Generating Random Numbers","title":"Random Number Generation","text":"main functions generating random numbers nv_runif(), nv_rdunif(), nv_rbinom(), nv_rnorm(). functions return list two elements: new RNG state (used subsequent random number generation) generated random numbers Let’s generate uniform random numbers: normally distributed random numbers:","code":"f <- jit(function(state) {   nv_runif(state, dtype = \"f32\", shape = c(2, 3)) })  result <- f(state) result[[1]]  # new state #> AnvilTensor  #>  42 #>   3 #> [ CPUui64{2} ] result[[2]]  # random numbers #> AnvilTensor  #>  0.8690 0.1506 0.5203 #>  0.3103 0.9928 0.1065 #> [ CPUf32{2x3} ] g <- jit(function(state) {   nv_rnorm(state, dtype = \"f32\", shape = c(2, 3), mu = 0, sigma = 1) })  result <- g(state) result[[2]] #> AnvilTensor  #>  -0.0675  0.9489  1.9457 #>  -0.5255  1.2002  0.0008 #> [ CPUf32{2x3} ]"},{"path":"/articles/random-numbers.html","id":"what-happens-when-you-reuse-the-state","dir":"Articles","previous_headings":"","what":"What Happens When You Reuse the State?","title":"Random Number Generation","text":"’s key insight: use state twice, get random numbers. can see, calls produced identical random numbers used state .","code":"h <- jit(function(state) {   result1 <- nv_runif(state, dtype = \"f32\", shape = 3L)   result2 <- nv_runif(state, dtype = \"f32\", shape = 3L)   list(first = result1[[2]], second = result2[[2]]) })  output <- h(state) as_array(output$first) #> [1] 0.8690484 0.3102535 0.1506324 as_array(output$second) #> [1] 0.8690484 0.3102535 0.1506324"},{"path":"/articles/random-numbers.html","id":"properly-chaining-random-number-generation","dir":"Articles","previous_headings":"","what":"Properly Chaining Random Number Generation","title":"Random Number Generation","text":"get different random numbers subsequent calls, need pass new state returned previous call: Now get different random numbers properly propagated state.","code":"proper_rng <- jit(function(state) {   result1 <- nv_runif(state, dtype = \"f32\", shape = c(3))   new_state <- result1[[1]]   result2 <- nv_runif(new_state, dtype = \"f32\", shape = c(3))   list(first = result1[[2]], second = result2[[2]]) })  output <- proper_rng(state) as_array(output$first) #> [1] 0.8690484 0.3102535 0.1506324 as_array(output$second) #> [1] 0.5203207 0.1064724 0.2499373"},{"path":"/articles/type-promotion.html","id":"type-promotion-rules","dir":"Articles","previous_headings":"","what":"Type Promotion Rules","title":"Type Promotion","text":"combining tensors different types (e.g., adding f32 i32), {anvil} needs determine common type. example, adding f32 f64, former promoted latter’s type, ’s expressive. type-promotion rules inspired JAX, designed execution accelerators like GPUs, one often wants speed instead precision. rules defined common_dtype() function. returns list() two values: common dtype flag indicating whether result ambiguous, cover later. table promotion rules . Type promotion rules (row × column)","code":"library(anvil) jit(nv_add)(   nv_scalar(1.0, dtype = \"f32\"),   nv_scalar(1.0, dtype = \"f64\") ) ## AnvilTensor  ##  2.0000 ## [ CPUf64{} ] common_dtype(\"f64\", \"f32\")$dtype ## <stablehlo::FloatType> ##  @ value: int 64 common_dtype(\"i64\", \"f32\")$dtype ## <stablehlo::FloatType> ##  @ value: int 32"},{"path":"/articles/type-promotion.html","id":"literals-as-ambiguous-types","dir":"Articles","previous_headings":"","what":"Literals as Ambiguous Types","title":"Type Promotion","text":"Usually, types {anvil} program can deterministically inferred input types. case possible use R literals. default types literals follows: double() -> dtype(\"f32\") integer() -> dtype(\"i32\") logical() -> dtype(\"i1\") (bool) However, just guess, behave differently known types promotion. Therefore, common_dtype function two arguments indicating data types ambiguous. , first type known f64 second ambiguous f32. Within anvil, denote latter i32?. result f64, although promote f64 known. types ambiguous, result generally known. promotion rules change one type ambiguous . , usually promote ambiguous type known type, unless: ambiguous type float known type . known type bool ambiguous type . case, promote known type default type ambiguous type. table shows promotion rules, rows ambiguous columns known. Promotion rules: ambiguous (row) × known (column)","code":"jit(\\() list(1L, 1.0, TRUE))() ## [[1]] ## AnvilTensor  ##  1 ## [ CPUi32{} ]  ##  ## [[2]] ## AnvilTensor  ##  1.0000 ## [ CPUf32{} ]  ##  ## [[3]] ## AnvilTensor  ##  1 ## [ CPUpred{} ] common_dtype(\"f32\", \"f64\", FALSE, TRUE) ## $dtype ## <stablehlo::FloatType> ##  @ value: int 32 ##  ## $ambiguous ## [1] FALSE common_dtype(\"f32\", \"f64\", TRUE, TRUE) ## $dtype ## <stablehlo::FloatType> ##  @ value: int 64 ##  ## $ambiguous ## [1] TRUE common_dtype(\"f32\", \"f64\", FALSE, FALSE) ## $dtype ## <stablehlo::FloatType> ##  @ value: int 64 ##  ## $ambiguous ## [1] FALSE"},{"path":"/articles/type-promotion.html","id":"propagating-ambiguity","dir":"Articles","previous_headings":"","what":"Propagating Ambiguity","title":"Type Promotion","text":"Ambiguity propagated operations. Consider following example: type z i32?, x promoted i32, default type 1L literal. z ambiguous, output i32, y promoted i32 multiplication. propagate ambiguity, z actually -promoted i16, z ambiguous, y known.","code":"f <- jit(function(x, y) {   z <- x + 1L   z * y }) f(nv_scalar(TRUE), nv_scalar(2L, dtype = \"i16\")) ## AnvilTensor  ##  4 ## [ CPUi16{} ]"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sebastian Fischer. Maintainer, author. Daniel Falbel. Author. Nikolai German. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Fischer S, Falbel D, German N (2026). anvil: Framework R code transformations. R package version 0.0.0.9000, https://r-xla.github.io/anvil/.","code":"@Manual{,   title = {anvil: Framework for R code transformations},   author = {Sebastian Fischer and Daniel Falbel and Nikolai German},   year = {2026},   note = {R package version 0.0.0.9000},   url = {https://r-xla.github.io/anvil/}, }"},{"path":"/index.html","id":"anvil","dir":"","previous_headings":"","what":"Framework for R code transformations","title":"Framework for R code transformations","text":"Composable code transformation framework R, allowing run numerical programs speed light. currently implements JIT compilation fast execution backward-mode automatic differentiation. Programs can run various hardware backends, including CPU GPU.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Framework for R code transformations","text":"order install source, need C++20 compiler, well libprotobuf protobuf-compiler. can also install r-universe, adding code .Rprofile.","code":"pak::pak(\"r-xla/anvil\") options(repos = c(   rxla = \"https://r-xla.r-universe.dev\",   CRAN = \"https://cloud.r-project.org/\" ))"},{"path":"/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Framework for R code transformations","text":", create standard R function. directly call function, first need wrap jit() call. resulting function called AnvilTensors – primary data type {anvil} – JIT compiled subsequently executed. automatic differentiation, can also obtain gradient function.","code":"library(anvil) f <- function(a, b, x) {   a * x + b } f_jit <- jit(f)  a <- nv_scalar(1.0) b <- nv_scalar(-2.0) x <- nv_scalar(3.0)  f_jit(a, b, x) #> AnvilTensor  #>  1.0000 #> [ CPUf32{} ] g_jit <- jit(gradient(f, wrt = c(\"a\", \"b\"))) g_jit(a, b, x) #> $a #> AnvilTensor  #>  3.0000 #> [ CPUf32{} ]  #>  #> $b #> AnvilTensor  #>  1.0000 #> [ CPUf32{} ]"},{"path":"/index.html","id":"main-features","dir":"","previous_headings":"","what":"Main Features","title":"Framework for R code transformations","text":"Gradients functions scalar outputs supported. Code JIT compiled single kernel. Runs different hardware backends, including CPU GPU. possible add new primitives, transformations, (effort) new backends. package written almost entirely R.","code":""},{"path":"/index.html","id":"when-to-use-this-package","dir":"","previous_headings":"","what":"When to use this package?","title":"Framework for R code transformations","text":"{anvil} allows run certain types programs extremely fast, applies certain category problems. Specifically, suitable numerical algorithms, optimizing bayesian models, training neural networks generally numerical optimization. Another restriction {anvil} needs re-compile code new unique input shape. advantage, compiler can make memory optimizations, compilation overhead might problem fast running programs.","code":""},{"path":"/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"Framework for R code transformations","text":"work supported MaRDI. JAX, especially autodidax tutorial. microjax project. JIT compilation, leverage OpenXLA project.","code":""},{"path":"/reference/AbstractTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Abstract Tensor Class — nv_aten","title":"Abstract Tensor Class — nv_aten","text":"Abstract representation tensor (possibly ambiguous) dtype shape, concrete data. Used tracing represent tensor metadata without actual values.","code":""},{"path":"/reference/AbstractTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Abstract Tensor Class — nv_aten","text":"","code":"nv_aten(dtype, shape)  AbstractTensor(dtype, shape, ambiguous = FALSE)"},{"path":"/reference/AbstractTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Abstract Tensor Class — nv_aten","text":"dtype (stablehlo::TensorDataType) data type tensor. shape (stablehlo::Shape | integer()) shape tensor. Can provided integer vector. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette \"Type Promotion\" details.","code":""},{"path":"/reference/AbstractTensor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Abstract Tensor Class — nv_aten","text":"Two tensors considered equal (==) dtype shape, ignoring ambiguity.","code":""},{"path":[]},{"path":"/reference/ConcreteTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Concrete Tensor Class — ConcreteTensor","title":"Concrete Tensor Class — ConcreteTensor","text":"AbstractTensor also holds reference actual tensor data. Used represent constants captured tracing. comes concrete tensor, type never ambiguous.","code":""},{"path":"/reference/ConcreteTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concrete Tensor Class — ConcreteTensor","text":"","code":"ConcreteTensor(data)"},{"path":"/reference/ConcreteTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concrete Tensor Class — ConcreteTensor","text":"data (AnvilTensor) actual tensor data.","code":""},{"path":[]},{"path":"/reference/DebugBox.html","id":null,"dir":"Reference","previous_headings":"","what":"Debug Box Class — DebugBox","title":"Debug Box Class — DebugBox","text":"Box representing value debug mode.","code":""},{"path":"/reference/DebugBox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Debug Box Class — DebugBox","text":"","code":"DebugBox(aval = AbstractTensor())"},{"path":"/reference/DebugBox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Debug Box Class — DebugBox","text":"aval (AbstractTensor) abstract tensor representing value.","code":""},{"path":"/reference/Graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph of Primitive Calls — Graph","title":"Graph of Primitive Calls — Graph","text":"Computational graph consisting exclusively primitive calls.","code":""},{"path":"/reference/Graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph of Primitive Calls — Graph","text":"","code":"Graph(   calls = list(),   in_tree = NULL,   out_tree = NULL,   inputs = list(),   outputs = list(),   constants = list() )"},{"path":"/reference/Graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph of Primitive Calls — Graph","text":"calls (list(PrimitiveCall)) primitive calls make graph. can also another call graph primitive p_call. in_tree (NULL | Node) tree inputs. out_tree (NULL | Node) tree outputs. inputs (list(GraphValue)) inputs graph. outputs (list(GraphValue)) outputs graph. constants (list(GraphValue)) constants graph.","code":""},{"path":"/reference/GraphBox.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Box — GraphBox","title":"Graph Box — GraphBox","text":"Box represents node GraphDescriptor.","code":""},{"path":"/reference/GraphBox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Box — GraphBox","text":"","code":"GraphBox(gnode = `mut<GraphValue>`(), desc = `mut<GraphDescriptor>`())"},{"path":"/reference/GraphBox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Box — GraphBox","text":"gnode (GraphNode) node. desc (GraphDescriptor) descriptor graph.","code":""},{"path":"/reference/GraphDescriptor.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Descriptor — GraphDescriptor","title":"Graph Descriptor — GraphDescriptor","text":"Descriptor Graph.","code":""},{"path":"/reference/GraphDescriptor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Descriptor — GraphDescriptor","text":"","code":"GraphDescriptor(   calls = list(),   tensor_to_gval = hashtab(),   gval_to_box = hashtab(),   constants = list(),   in_tree = NULL,   out_tree = NULL,   inputs = list(),   outputs = list() )"},{"path":"/reference/GraphDescriptor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Descriptor — GraphDescriptor","text":"calls (list(PrimitiveCall)) primitive calls make graph. tensor_to_gval (hashtab) Mapping: AnvilTensor -> GraphValue gval_to_box (hashtab) Mapping: GraphValue -> GraphBox constants (list(GraphValue)) constants graph. in_tree (NULL | Node) tree inputs. out_tree (NULL | Node) tree outputs. inputs (list(GraphValue)) inputs graph. outputs (list(GraphValue)) outputs graph.","code":""},{"path":"/reference/GraphLiteral.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Literal — GraphLiteral","title":"Graph Literal — GraphLiteral","text":"Literal Graph.","code":""},{"path":"/reference/GraphLiteral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Literal — GraphLiteral","text":"","code":"GraphLiteral(aval = LiteralTensor())"},{"path":"/reference/GraphLiteral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Literal — GraphLiteral","text":"aval () value literal.","code":""},{"path":"/reference/GraphNode.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Node — GraphNode","title":"Graph Node — GraphNode","text":"Node Graph. either GraphValue GraphLiteral.","code":""},{"path":"/reference/GraphNode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Node — GraphNode","text":"","code":"GraphNode"},{"path":"/reference/GraphNode.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Graph Node — GraphNode","text":"object class S7_union length 1.","code":""},{"path":"/reference/GraphValue.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph Value — GraphValue","title":"Graph Value — GraphValue","text":"Value Graph.","code":""},{"path":"/reference/GraphValue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph Value — GraphValue","text":"","code":"GraphValue(aval = AbstractTensor())"},{"path":"/reference/GraphValue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph Value — GraphValue","text":"aval (AbstractTensor) abstract value variable.","code":""},{"path":"/reference/LiteralTensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Literal Tensor Class — LiteralTensor","title":"Literal Tensor Class — LiteralTensor","text":"AbstractTensor representing tensor data R scalar literal (e.g., 1L, 2.5). Usually, type ambiguous, unless created via nv_fill.","code":""},{"path":"/reference/LiteralTensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Literal Tensor Class — LiteralTensor","text":"","code":"LiteralTensor(data, shape, dtype = default_dtype(data), ambiguous)"},{"path":"/reference/LiteralTensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Literal Tensor Class — LiteralTensor","text":"data (numeric(1) | integer(1) | logical(1)) scalar value. shape (stablehlo::Shape | integer()) shape tensor. dtype (stablehlo::TensorDataType) data type. Defaults f32 numeric, i32 integer, i1 logical. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette \"Type Promotion\" details.","code":""},{"path":[]},{"path":"/reference/Primitive.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive — Primitive","title":"Primitive — Primitive","text":"Primitive interpretation rule.","code":""},{"path":"/reference/Primitive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive — Primitive","text":"","code":"Primitive(name)"},{"path":"/reference/Primitive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive — Primitive","text":"name (character()) name primitive.","code":""},{"path":"/reference/Primitive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive — Primitive","text":"(Primitive)","code":""},{"path":"/reference/PrimitiveCall.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Call — PrimitiveCall","title":"Primitive Call — PrimitiveCall","text":"Call primitive Graph Note primitive call also call another graph (p_graph).","code":""},{"path":"/reference/PrimitiveCall.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Call — PrimitiveCall","text":"","code":"PrimitiveCall(   primitive = Primitive(),   inputs = list(),   params = list(),   outputs = list() )"},{"path":"/reference/PrimitiveCall.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Call — PrimitiveCall","text":"primitive (Primitive) function. inputs (list(GraphValue)) (tensor) inputs primitive. params (list(<>)) (static) parameters function call. outputs (list(GraphValue)) (tensor) outputs primitive.","code":""},{"path":"/reference/abstract_properties.html","id":null,"dir":"Reference","previous_headings":"","what":"Abstract Properties — abstract_properties","title":"Abstract Properties — abstract_properties","text":"Calls extractor converting input AbstractTensor.","code":""},{"path":"/reference/abstract_properties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Abstract Properties — abstract_properties","text":"","code":"shape_abstract(x)  ndims_abstract(x)  dtype_abstract(x)"},{"path":"/reference/abstract_properties.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Abstract Properties — abstract_properties","text":"x (tensorish)","code":""},{"path":"/reference/assert_shapevec.html","id":null,"dir":"Reference","previous_headings":"","what":"Assert Shape Vector — assert_shapevec","title":"Assert Shape Vector — assert_shapevec","text":"Check whether input valid shape vector (integer vector positive values).","code":""},{"path":"/reference/assert_shapevec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assert Shape Vector — assert_shapevec","text":"","code":"assert_shapevec(x, min_len = 1L, var_name = rlang::caller_arg(x))"},{"path":"/reference/assert_shapevec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assert Shape Vector — assert_shapevec","text":"x Object check. min_len (integer(1)) Minimum length shape vector. Default 1. var_name (character(1)) Name variable use error messages.","code":""},{"path":"/reference/assert_shapevec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assert Shape Vector — assert_shapevec","text":"Invisibly returns x assertion passes.","code":""},{"path":"/reference/common_dtype.html","id":null,"dir":"Reference","previous_headings":"","what":"Type Promotion Rules — common_dtype","title":"Type Promotion Rules — common_dtype","text":"Computes common dtype set abstract types, respecting whether type ambiguous . type ambiguous comes literal (like 1 1.0) promoted ambiguous type. Promoting ambiguous type can happen scenarios like x + 1.2, x bool int.","code":""},{"path":"/reference/common_dtype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type Promotion Rules — common_dtype","text":"","code":"common_dtype(   lhs_dtype,   rhs_dtype,   lhs_ambiguous = FALSE,   rhs_ambiguous = FALSE )"},{"path":"/reference/common_dtype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type Promotion Rules — common_dtype","text":"lhs_dtype (stablehlo::TensorDataType) left-hand side type. rhs_dtype (stablehlo::TensorDataType) right-hand side type. lhs_ambiguous (logical(1)) Whether left-hand side type ambiguous. rhs_ambiguous (logical(1)) Whether right-hand side type ambiguous.","code":""},{"path":"/reference/common_dtype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Type Promotion Rules — common_dtype","text":"(list(dtype = [stablehlo::TensorDataType], ambiguous = logical(1)`)","code":""},{"path":"/reference/debug_box.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Debug Box — debug_box","title":"Create a Debug Box — debug_box","text":"Create debug box.","code":""},{"path":"/reference/debug_box.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Debug Box — debug_box","text":"","code":"debug_box(dtype, shape, ambiguous = FALSE)"},{"path":"/reference/debug_box.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Debug Box — debug_box","text":"dtype (character(1) | stablehlo::TensorDataType) Data type. shape (integer()) Shape. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette \"Type Promotion\" details.","code":""},{"path":"/reference/debug_box.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Debug Box — debug_box","text":"(DebugBox)","code":""},{"path":"/reference/dot-current_descriptor.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the current graph — .current_descriptor","title":"Get the current graph — .current_descriptor","text":"Get current graph built (via local_descriptor).","code":""},{"path":"/reference/dot-current_descriptor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the current graph — .current_descriptor","text":"","code":".current_descriptor(silent = FALSE)"},{"path":"/reference/dot-current_descriptor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the current graph — .current_descriptor","text":"silent (logical(1)) Whether return NULL graph currently built (opposed aborting).","code":""},{"path":"/reference/dot-current_descriptor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the current graph — .current_descriptor","text":"GraphDescriptor object.","code":""},{"path":"/reference/gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient — gradient","title":"Gradient — gradient","text":"Transform function gradient.","code":""},{"path":"/reference/gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient — gradient","text":"","code":"gradient(f, wrt = NULL)  value_and_gradient(f, wrt = NULL)"},{"path":"/reference/gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient — gradient","text":"f (function) Function compute gradient . wrt (character) Names arguments compute gradient respect .","code":""},{"path":"/reference/gradient.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Gradient — gradient","text":"value_and_gradient(): Returns value gradient","code":""},{"path":"/reference/graph_desc_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"Add primitive call graph descriptor.","code":""},{"path":"/reference/graph_desc_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"","code":"graph_desc_add(   prim,   args,   params = list(),   infer_fn,   desc = NULL,   debug_mode = NULL )"},{"path":"/reference/graph_desc_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"prim (Primitive) primitive add. args (list GraphNode) arguments primitive. params (list) parameters primitive. infer_fn (function) inference function use. Must output list AbstractTensors. desc (GraphDescriptor | NULL) graph descriptor add primitive call . Uses current descriptor NULL. debug_mode (logical(1)) Whether just perform abstract evaluation debugging.","code":""},{"path":"/reference/graph_desc_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a Primitive Call to a Graph Descriptor — graph_desc_add","text":"(list Box) Either GraphBox objects DebugBox objects, depending debug_mode.","code":""},{"path":"/reference/graph_to_quickr_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a Graph to a quickr-compiled function — graph_to_quickr_function","title":"Convert a Graph to a quickr-compiled function — graph_to_quickr_function","text":"Lowers supported subset anvil::Graph objects plain R function compiles quickr::quick().","code":""},{"path":"/reference/graph_to_quickr_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a Graph to a quickr-compiled function — graph_to_quickr_function","text":"","code":"graph_to_quickr_function(graph)"},{"path":"/reference/graph_to_quickr_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a Graph to a quickr-compiled function — graph_to_quickr_function","text":"graph (Graph) Graph convert.","code":""},{"path":"/reference/graph_to_quickr_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a Graph to a quickr-compiled function — graph_to_quickr_function","text":"(function)","code":""},{"path":"/reference/graph_to_quickr_function.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a Graph to a quickr-compiled function — graph_to_quickr_function","text":"returned function expects plain R scalars/vectors/arrays (AnvilTensor) returns plain R values/arrays. graph returns multiple outputs (e.g. nested list), compiled function returns structure packing/unpacking values quickr. moment supports graphs flat (non-nested) argument list. Currently supported primitives : constant, add, sub, mul, divide, negate, broadcast_in_dim, dot_general, transpose, reshape, sum. code generator currently supports tensors rank 5. primitives restricted (e.g. transpose currently handles rank-2 tensors).","code":""},{"path":"/reference/jit.html","id":null,"dir":"Reference","previous_headings":"","what":"JIT compile a function — jit","title":"JIT compile a function — jit","text":"Convert function JIT compiled function.","code":""},{"path":"/reference/jit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"JIT compile a function — jit","text":"","code":"jit(   f,   static = character(),   cache_size = 100L,   donate = character(),   device = NULL )"},{"path":"/reference/jit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"JIT compile a function — jit","text":"f (function) Function compile. static (character()) parameters f static. cache_size (integer(1)) size cache jit-compiled functions. donate (character()) Names arguments whose buffers donated. Donated buffers can aliased outputs type, allowing -place operations reducing memory usage. device (NULL | character(1) | PJRTDevice) device use input tensors provided infer platform.","code":""},{"path":"/reference/jit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"JIT compile a function — jit","text":"(function)","code":""},{"path":"/reference/jit_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Jit an Evaluate an Expression — jit_eval","title":"Jit an Evaluate an Expression — jit_eval","text":"Compiles evaluates expression.","code":""},{"path":"/reference/jit_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jit an Evaluate an Expression — jit_eval","text":"","code":"jit_eval(expr)"},{"path":"/reference/jit_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jit an Evaluate an Expression — jit_eval","text":"expr (expression) Expression run.","code":""},{"path":"/reference/jit_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Jit an Evaluate an Expression — jit_eval","text":"() Result expression.","code":""},{"path":"/reference/local_descriptor.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a graph — local_descriptor","title":"Create a graph — local_descriptor","text":"Creates new Graph afterwards accessible via .current_descriptor(). graph automatically removed exiting current scope. graph either cleaned automatically (exiting scope) finalized, previously built graph restored, .e., accessible via .current_descriptor().","code":""},{"path":"/reference/local_descriptor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a graph — local_descriptor","text":"","code":"local_descriptor(..., envir = parent.frame())"},{"path":"/reference/local_descriptor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a graph — local_descriptor","text":"... () Additional arguments pass GraphDescriptor constructor. envir (environment) Environment exit handler registered cleaning Graph returned yet.","code":""},{"path":"/reference/local_descriptor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a graph — local_descriptor","text":"Graph object.","code":""},{"path":"/reference/mut.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an S7 class to a mutable S7 object — mut","title":"Convert an S7 class to a mutable S7 object — mut","text":"Convert S7 class mutable S7 object","code":""},{"path":"/reference/mut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an S7 class to a mutable S7 object — mut","text":"","code":"mut(x)"},{"path":"/reference/mut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an S7 class to a mutable S7 object — mut","text":"x S7_class S7_class class constructor - function otherwise call create new object class.","code":""},{"path":"/reference/mut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an S7 class to a mutable S7 object — mut","text":"","code":"library(S7)  class_ex <- new_class(   \"class_example\",   properties = list(     # validators     value = new_property(       class = class_integer,       validator = function(value) {         if (value == 0L) \"value cannot be exactly 0\"       }     ),     # read-only properties     is_gt_0 = new_property(       class = class_logical,       getter = function(self) {         self@value > 0       }     )   ) )  # make a mutable version of our class ex <- mut(class_ex)(value = 3L) ex@value #> [1] 3  # we can make a copy and update our value property ex_ref <- ex ex_ref@value <- 30L  # all values reference the same data, our original is updated ex@value #> [1] 30"},{"path":"/reference/nv_abs.html","id":null,"dir":"Reference","previous_headings":"","what":"Absolute Value — nv_abs","title":"Absolute Value — nv_abs","text":"Element-wise absolute value.","code":""},{"path":"/reference/nv_abs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Absolute Value — nv_abs","text":"","code":"nv_abs(operand)"},{"path":"/reference/nv_abs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Absolute Value — nv_abs","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_abs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Absolute Value — nv_abs","text":"tensorish","code":""},{"path":"/reference/nv_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Addition — nv_add","title":"Addition — nv_add","text":"Element-wise addition two tensors.","code":""},{"path":"/reference/nv_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Addition — nv_add","text":"","code":"nv_add(lhs, rhs)"},{"path":"/reference/nv_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Addition — nv_add","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Addition — nv_add","text":"tensorish","code":""},{"path":"/reference/nv_and.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical And — nv_and","title":"Logical And — nv_and","text":"Element-wise logical operation.","code":""},{"path":"/reference/nv_and.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical And — nv_and","text":"","code":"nv_and(lhs, rhs)"},{"path":"/reference/nv_and.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical And — nv_and","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_and.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical And — nv_and","text":"tensorish","code":""},{"path":"/reference/nv_atan2.html","id":null,"dir":"Reference","previous_headings":"","what":"Arctangent 2 — nv_atan2","title":"Arctangent 2 — nv_atan2","text":"Element-wise two-argument arctangent.","code":""},{"path":"/reference/nv_atan2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arctangent 2 — nv_atan2","text":"","code":"nv_atan2(lhs, rhs)"},{"path":"/reference/nv_atan2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arctangent 2 — nv_atan2","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_atan2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arctangent 2 — nv_atan2","text":"tensorish","code":""},{"path":"/reference/nv_bitcast_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Bitcast Conversion — nv_bitcast_convert","title":"Bitcast Conversion — nv_bitcast_convert","text":"Reinterpret Bits","code":""},{"path":"/reference/nv_bitcast_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bitcast Conversion — nv_bitcast_convert","text":"","code":"nv_bitcast_convert(operand, dtype)"},{"path":"/reference/nv_bitcast_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bitcast Conversion — nv_bitcast_convert","text":"operand (tensorish) Operand. dtype requested dtype","code":""},{"path":"/reference/nv_broadcast_scalars.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"Broadcast scalar tensors match shape non-scalar tensors. non-scalar tensors must shape.","code":""},{"path":"/reference/nv_broadcast_scalars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"","code":"nv_broadcast_scalars(...)"},{"path":"/reference/nv_broadcast_scalars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"... (tensorish) Tensors broadcast. Scalars broadcast common non-scalar shape.","code":""},{"path":"/reference/nv_broadcast_scalars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcast Scalars to Common Shape — nv_broadcast_scalars","text":"(list() tensorish) List broadcasted tensors.","code":""},{"path":"/reference/nv_broadcast_tensors.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"Broadcast tensors common shape.","code":""},{"path":"/reference/nv_broadcast_tensors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"","code":"nv_broadcast_tensors(...)"},{"path":"/reference/nv_broadcast_tensors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"... (tensorish) Tensors broadcast.","code":""},{"path":"/reference/nv_broadcast_tensors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"(list() tensorish)","code":""},{"path":"/reference/nv_broadcast_tensors.html","id":"broadcasting-rules","dir":"Reference","previous_headings":"","what":"Broadcasting Rules","title":"Broadcast Tensors to a Common Shape — nv_broadcast_tensors","text":"follow standard NumPy broadcasting rules: tensors different numbers dimensions, prepend 1s shape smaller tensor. dimension, : sizes , nothing. one tensors size 1, expand corresponding size tensor. sizes different neither 1, raise error.","code":""},{"path":"/reference/nv_broadcast_to.html","id":null,"dir":"Reference","previous_headings":"","what":"Broadcast — nv_broadcast_to","title":"Broadcast — nv_broadcast_to","text":"Broadcast tensor given shape using NumPy broadcasting rules.","code":""},{"path":"/reference/nv_broadcast_to.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broadcast — nv_broadcast_to","text":"","code":"nv_broadcast_to(operand, shape)"},{"path":"/reference/nv_broadcast_to.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broadcast — nv_broadcast_to","text":"operand (tensorish) Operand. shape (integer()) Output shape.","code":""},{"path":"/reference/nv_broadcast_to.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broadcast — nv_broadcast_to","text":"(tensorish)","code":""},{"path":"/reference/nv_cbrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Cube Root — nv_cbrt","title":"Cube Root — nv_cbrt","text":"Element-wise cube root.","code":""},{"path":"/reference/nv_cbrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cube Root — nv_cbrt","text":"","code":"nv_cbrt(operand)"},{"path":"/reference/nv_cbrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cube Root — nv_cbrt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_cbrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cube Root — nv_cbrt","text":"tensorish","code":""},{"path":"/reference/nv_ceil.html","id":null,"dir":"Reference","previous_headings":"","what":"Ceiling — nv_ceil","title":"Ceiling — nv_ceil","text":"Element-wise ceiling (round toward positive infinity).","code":""},{"path":"/reference/nv_ceil.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ceiling — nv_ceil","text":"","code":"nv_ceil(operand)"},{"path":"/reference/nv_ceil.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ceiling — nv_ceil","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_ceil.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ceiling — nv_ceil","text":"tensorish","code":""},{"path":"/reference/nv_clamp.html","id":null,"dir":"Reference","previous_headings":"","what":"Clamp — nv_clamp","title":"Clamp — nv_clamp","text":"Element-wise clamp: max(min_val, min(operand, max_val)).","code":""},{"path":"/reference/nv_clamp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clamp — nv_clamp","text":"","code":"nv_clamp(min_val, operand, max_val)"},{"path":"/reference/nv_clamp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clamp — nv_clamp","text":"min_val (tensorish) Minimum value. operand (tensorish) Operand. max_val (tensorish) Maximum value.","code":""},{"path":"/reference/nv_clamp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clamp — nv_clamp","text":"tensorish","code":""},{"path":"/reference/nv_clamp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clamp — nv_clamp","text":"underlying stableHLO function already broadcasts scalars, need broadcast manually.","code":""},{"path":"/reference/nv_concatenate.html","id":null,"dir":"Reference","previous_headings":"","what":"Concatenate — nv_concatenate","title":"Concatenate — nv_concatenate","text":"Concatenate variadic number tensors.","code":""},{"path":"/reference/nv_concatenate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concatenate — nv_concatenate","text":"","code":"nv_concatenate(..., dimension)"},{"path":"/reference/nv_concatenate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concatenate — nv_concatenate","text":"... tensors dimension (integer()) dimension concatenate along . dimensions must .","code":""},{"path":"/reference/nv_concatenate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Concatenate — nv_concatenate","text":"tensorish","code":""},{"path":"/reference/nv_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Tensor to Different Data Type — nv_convert","title":"Convert Tensor to Different Data Type — nv_convert","text":"Convert tensor different data type.","code":""},{"path":"/reference/nv_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Tensor to Different Data Type — nv_convert","text":"","code":"nv_convert(operand, dtype)"},{"path":"/reference/nv_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Tensor to Different Data Type — nv_convert","text":"operand (tensorish) Operand. dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"/reference/nv_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Tensor to Different Data Type — nv_convert","text":"tensorish","code":""},{"path":"/reference/nv_cosine.html","id":null,"dir":"Reference","previous_headings":"","what":"Cosine — nv_cosine","title":"Cosine — nv_cosine","text":"Element-wise cosine.","code":""},{"path":"/reference/nv_cosine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cosine — nv_cosine","text":"","code":"nv_cosine(operand)"},{"path":"/reference/nv_cosine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cosine — nv_cosine","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_cosine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cosine — nv_cosine","text":"tensorish","code":""},{"path":"/reference/nv_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Division — nv_div","title":"Division — nv_div","text":"Element-wise division two tensors.","code":""},{"path":"/reference/nv_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Division — nv_div","text":"","code":"nv_div(lhs, rhs)"},{"path":"/reference/nv_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Division — nv_div","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Division — nv_div","text":"tensorish","code":""},{"path":"/reference/nv_eq.html","id":null,"dir":"Reference","previous_headings":"","what":"Equal — nv_eq","title":"Equal — nv_eq","text":"Element-wise equality comparison.","code":""},{"path":"/reference/nv_eq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equal — nv_eq","text":"","code":"nv_eq(lhs, rhs)"},{"path":"/reference/nv_eq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Equal — nv_eq","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_eq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Equal — nv_eq","text":"tensorish","code":""},{"path":"/reference/nv_exp.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential — nv_exp","title":"Exponential — nv_exp","text":"Element-wise exponential function.","code":""},{"path":"/reference/nv_exp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential — nv_exp","text":"","code":"nv_exp(operand)"},{"path":"/reference/nv_exp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential — nv_exp","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_exp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential — nv_exp","text":"tensorish","code":""},{"path":"/reference/nv_expm1.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential Minus One — nv_expm1","title":"Exponential Minus One — nv_expm1","text":"Element-wise exp(x) - 1, accurate small x.","code":""},{"path":"/reference/nv_expm1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential Minus One — nv_expm1","text":"","code":"nv_expm1(operand)"},{"path":"/reference/nv_expm1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential Minus One — nv_expm1","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_expm1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential Minus One — nv_expm1","text":"tensorish","code":""},{"path":"/reference/nv_fill.html","id":null,"dir":"Reference","previous_headings":"","what":"Constant — nv_fill","title":"Constant — nv_fill","text":"Create constant.","code":""},{"path":"/reference/nv_fill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constant — nv_fill","text":"","code":"nv_fill(value, shape, dtype = NULL)"},{"path":"/reference/nv_fill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constant — nv_fill","text":"value () Value. shape (integer()) Shape. dtype (character(1)) Data type.","code":""},{"path":"/reference/nv_floor.html","id":null,"dir":"Reference","previous_headings":"","what":"Floor — nv_floor","title":"Floor — nv_floor","text":"Element-wise floor (round toward negative infinity).","code":""},{"path":"/reference/nv_floor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Floor — nv_floor","text":"","code":"nv_floor(operand)"},{"path":"/reference/nv_floor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Floor — nv_floor","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_floor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Floor — nv_floor","text":"tensorish","code":""},{"path":"/reference/nv_ge.html","id":null,"dir":"Reference","previous_headings":"","what":"Greater Than or Equal — nv_ge","title":"Greater Than or Equal — nv_ge","text":"Element-wise greater equal comparison.","code":""},{"path":"/reference/nv_ge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greater Than or Equal — nv_ge","text":"","code":"nv_ge(lhs, rhs)"},{"path":"/reference/nv_ge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Greater Than or Equal — nv_ge","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_ge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greater Than or Equal — nv_ge","text":"tensorish","code":""},{"path":"/reference/nv_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"Greater Than — nv_gt","title":"Greater Than — nv_gt","text":"Element-wise greater comparison.","code":""},{"path":"/reference/nv_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Greater Than — nv_gt","text":"","code":"nv_gt(lhs, rhs)"},{"path":"/reference/nv_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Greater Than — nv_gt","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Greater Than — nv_gt","text":"tensorish","code":""},{"path":"/reference/nv_if.html","id":null,"dir":"Reference","previous_headings":"","what":"If — nv_if","title":"If — nv_if","text":"Functional statement.","code":""},{"path":"/reference/nv_if.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"If — nv_if","text":"","code":"nv_if(pred, true, false)"},{"path":"/reference/nv_if.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"If — nv_if","text":"pred (tensorish) Flag. true (NSE) Expression evaluate condition true. false (NSE) Expression evaluate condition false.","code":""},{"path":"/reference/nv_if.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"If — nv_if","text":"tensorish","code":""},{"path":"/reference/nv_iota.html","id":null,"dir":"Reference","previous_headings":"","what":"Iota — nv_iota","title":"Iota — nv_iota","text":"Creates tensor values increasing along specified dimension.","code":""},{"path":"/reference/nv_iota.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iota — nv_iota","text":"","code":"nv_iota(dim, dtype, shape)"},{"path":"/reference/nv_iota.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iota — nv_iota","text":"dim (integer(1)) Dimension along values increase. dtype (character(1) | stablehlo::TensorDataType) Data type. shape (integer()) Shape.","code":""},{"path":"/reference/nv_iota.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iota — nv_iota","text":"tensorish","code":""},{"path":"/reference/nv_is_finite.html","id":null,"dir":"Reference","previous_headings":"","what":"Is Finite — nv_is_finite","title":"Is Finite — nv_is_finite","text":"Element-wise check values finite (Inf, -Inf, NaN).","code":""},{"path":"/reference/nv_is_finite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is Finite — nv_is_finite","text":"","code":"nv_is_finite(operand)"},{"path":"/reference/nv_is_finite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is Finite — nv_is_finite","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_is_finite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is Finite — nv_is_finite","text":"tensorish boolean type","code":""},{"path":"/reference/nv_le.html","id":null,"dir":"Reference","previous_headings":"","what":"Less Than or Equal — nv_le","title":"Less Than or Equal — nv_le","text":"Element-wise less equal comparison.","code":""},{"path":"/reference/nv_le.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Less Than or Equal — nv_le","text":"","code":"nv_le(lhs, rhs)"},{"path":"/reference/nv_le.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Less Than or Equal — nv_le","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_le.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Less Than or Equal — nv_le","text":"tensorish","code":""},{"path":"/reference/nv_log.html","id":null,"dir":"Reference","previous_headings":"","what":"Natural Logarithm — nv_log","title":"Natural Logarithm — nv_log","text":"Element-wise natural logarithm.","code":""},{"path":"/reference/nv_log.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Natural Logarithm — nv_log","text":"","code":"nv_log(operand)"},{"path":"/reference/nv_log.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Natural Logarithm — nv_log","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_log.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Natural Logarithm — nv_log","text":"tensorish","code":""},{"path":"/reference/nv_log1p.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Plus One — nv_log1p","title":"Log Plus One — nv_log1p","text":"Element-wise log(1 + x), accurate small x.","code":""},{"path":"/reference/nv_log1p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Plus One — nv_log1p","text":"","code":"nv_log1p(operand)"},{"path":"/reference/nv_log1p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Plus One — nv_log1p","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_log1p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Plus One — nv_log1p","text":"tensorish","code":""},{"path":"/reference/nv_logistic.html","id":null,"dir":"Reference","previous_headings":"","what":"Logistic (Sigmoid) — nv_logistic","title":"Logistic (Sigmoid) — nv_logistic","text":"Element-wise logistic sigmoid: 1 / (1 + exp(-x)).","code":""},{"path":"/reference/nv_logistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logistic (Sigmoid) — nv_logistic","text":"","code":"nv_logistic(operand)"},{"path":"/reference/nv_logistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logistic (Sigmoid) — nv_logistic","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_logistic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logistic (Sigmoid) — nv_logistic","text":"tensorish","code":""},{"path":"/reference/nv_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"Less Than — nv_lt","title":"Less Than — nv_lt","text":"Element-wise less comparison.","code":""},{"path":"/reference/nv_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Less Than — nv_lt","text":"","code":"nv_lt(lhs, rhs)"},{"path":"/reference/nv_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Less Than — nv_lt","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Less Than — nv_lt","text":"tensorish","code":""},{"path":"/reference/nv_matmul.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Multiplication — nv_matmul","title":"Matrix Multiplication — nv_matmul","text":"Matrix multiplication two tensors.","code":""},{"path":"/reference/nv_matmul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Multiplication — nv_matmul","text":"","code":"nv_matmul(lhs, rhs)"},{"path":"/reference/nv_matmul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Multiplication — nv_matmul","text":"lhs (tensorish) rhs (tensorish)","code":""},{"path":"/reference/nv_matmul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Multiplication — nv_matmul","text":"tensorish","code":""},{"path":"/reference/nv_matmul.html","id":"shapes","dir":"Reference","previous_headings":"","what":"Shapes","title":"Matrix Multiplication — nv_matmul","text":"lhs: (b1, ..., bk, m, n) rhs: (b1, ..., bk, n, p) output: (b1, ..., bk, m, p)","code":""},{"path":"/reference/nv_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum — nv_max","title":"Maximum — nv_max","text":"Element-wise maximum two tensors.","code":""},{"path":"/reference/nv_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum — nv_max","text":"","code":"nv_max(lhs, rhs)"},{"path":"/reference/nv_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum — nv_max","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum — nv_max","text":"tensorish","code":""},{"path":"/reference/nv_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimum — nv_min","title":"Minimum — nv_min","text":"Element-wise minimum two tensors.","code":""},{"path":"/reference/nv_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimum — nv_min","text":"","code":"nv_min(lhs, rhs)"},{"path":"/reference/nv_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimum — nv_min","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimum — nv_min","text":"tensorish","code":""},{"path":"/reference/nv_mul.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiplication — nv_mul","title":"Multiplication — nv_mul","text":"Element-wise multiplication two tensors.","code":""},{"path":"/reference/nv_mul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiplication — nv_mul","text":"","code":"nv_mul(lhs, rhs)"},{"path":"/reference/nv_mul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiplication — nv_mul","text":"lhs (tensorish) rhs (tensorish)","code":""},{"path":"/reference/nv_mul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiplication — nv_mul","text":"tensorish","code":""},{"path":"/reference/nv_ne.html","id":null,"dir":"Reference","previous_headings":"","what":"Not Equal — nv_ne","title":"Not Equal — nv_ne","text":"Element-wise inequality comparison.","code":""},{"path":"/reference/nv_ne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Not Equal — nv_ne","text":"","code":"nv_ne(lhs, rhs)"},{"path":"/reference/nv_ne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Not Equal — nv_ne","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_ne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Not Equal — nv_ne","text":"tensorish","code":""},{"path":"/reference/nv_neg.html","id":null,"dir":"Reference","previous_headings":"","what":"Negation — nv_neg","title":"Negation — nv_neg","text":"Element-wise negation.","code":""},{"path":"/reference/nv_neg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negation — nv_neg","text":"","code":"nv_neg(operand)"},{"path":"/reference/nv_neg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negation — nv_neg","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_neg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negation — nv_neg","text":"tensorish","code":""},{"path":"/reference/nv_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Not — nv_not","title":"Logical Not — nv_not","text":"Element-wise logical operation.","code":""},{"path":"/reference/nv_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Not — nv_not","text":"","code":"nv_not(operand)"},{"path":"/reference/nv_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Not — nv_not","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Not — nv_not","text":"tensorish","code":""},{"path":"/reference/nv_or.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Or — nv_or","title":"Logical Or — nv_or","text":"Element-wise logical operation.","code":""},{"path":"/reference/nv_or.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Or — nv_or","text":"","code":"nv_or(lhs, rhs)"},{"path":"/reference/nv_or.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Or — nv_or","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_or.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Or — nv_or","text":"tensorish","code":""},{"path":"/reference/nv_pad.html","id":null,"dir":"Reference","previous_headings":"","what":"Pad — nv_pad","title":"Pad — nv_pad","text":"Pads tensor given padding value.","code":""},{"path":"/reference/nv_pad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pad — nv_pad","text":"","code":"nv_pad(   operand,   padding_value,   edge_padding_low,   edge_padding_high,   interior_padding = NULL )"},{"path":"/reference/nv_pad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pad — nv_pad","text":"operand (tensorish) Operand. padding_value (tensorish) Scalar value use padding. edge_padding_low (integer()) Amount padding add start dimension. edge_padding_high (integer()) Amount padding add end dimension. interior_padding (integer()) Amount padding add elements dimension (default 0).","code":""},{"path":"/reference/nv_pad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pad — nv_pad","text":"tensorish","code":""},{"path":"/reference/nv_popcnt.html","id":null,"dir":"Reference","previous_headings":"","what":"Population Count — nv_popcnt","title":"Population Count — nv_popcnt","text":"Element-wise population count (number set bits integer).","code":""},{"path":"/reference/nv_popcnt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Population Count — nv_popcnt","text":"","code":"nv_popcnt(operand)"},{"path":"/reference/nv_popcnt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Population Count — nv_popcnt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_popcnt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Population Count — nv_popcnt","text":"tensorish","code":""},{"path":"/reference/nv_pow.html","id":null,"dir":"Reference","previous_headings":"","what":"Power — nv_pow","title":"Power — nv_pow","text":"Element-wise exponentiation two tensors.","code":""},{"path":"/reference/nv_pow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Power — nv_pow","text":"","code":"nv_pow(lhs, rhs)"},{"path":"/reference/nv_pow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Power — nv_pow","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_pow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Power — nv_pow","text":"tensorish","code":""},{"path":"/reference/nv_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Tensor — nv_print","title":"Print Tensor — nv_print","text":"Prints tensor JIT execution.","code":""},{"path":"/reference/nv_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Tensor — nv_print","text":"","code":"nv_print(operand)"},{"path":"/reference/nv_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Tensor — nv_print","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_promote_to_common.html","id":null,"dir":"Reference","previous_headings":"","what":"Promote Tensors to a Common Dtype — nv_promote_to_common","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"Promote tensors common data type, see common_dtype details.","code":""},{"path":"/reference/nv_promote_to_common.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"","code":"nv_promote_to_common(...)"},{"path":"/reference/nv_promote_to_common.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"... (tensorish) Tensors promote.","code":""},{"path":"/reference/nv_promote_to_common.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Promote Tensors to a Common Dtype — nv_promote_to_common","text":"(list() tensorish)","code":""},{"path":"/reference/nv_rbinom.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Binomial Distribution — nv_rbinom","title":"Sample from a Binomial Distribution — nv_rbinom","text":"Sample binomial distribution $n$ trials success probability $p$.","code":""},{"path":"/reference/nv_rbinom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Binomial Distribution — nv_rbinom","text":"","code":"nv_rbinom(shape, initial_state, n = 1L, prob = 0.5, dtype = \"i32\")"},{"path":"/reference/nv_rbinom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Binomial Distribution — nv_rbinom","text":"shape (integer()) Shape. initial_state ([ui64[2]][tensorish]) RNG state. n (integer(1)) Number trials. Default 1 (Bernoulli). prob (numeric(1)) Probability success trial. Default 0.5. dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"/reference/nv_rbinom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Binomial Distribution — nv_rbinom","text":"(list() tensorish) List two tensors: new RNG state generated random samples.","code":""},{"path":"/reference/nv_rdunif.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Discrete Uniform Distribution — nv_rdunif","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"Sample discrete distribution, analogous R's sample() function. Samples integers 1 n uniform probability replacement.","code":""},{"path":"/reference/nv_rdunif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"","code":"nv_rdunif(shape, initial_state, n, dtype = \"i32\")"},{"path":"/reference/nv_rdunif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"shape (integer()) Shape. initial_state ([ui64[2]][tensorish]) RNG state. n (integer(1)) Number categories sample (samples integers 1 n). dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"/reference/nv_rdunif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Discrete Uniform Distribution — nv_rdunif","text":"(list() tensorish) List two tensors: new RNG state sampled integers.","code":""},{"path":"/reference/nv_reduce_ops.html","id":null,"dir":"Reference","previous_headings":"","what":"Reduction Operators — nv_reduce_ops","title":"Reduction Operators — nv_reduce_ops","text":"Reduce tensor along specified dimensions.","code":""},{"path":"/reference/nv_reduce_ops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reduction Operators — nv_reduce_ops","text":"","code":"nv_reduce_sum(operand, dims, drop = TRUE)  nv_reduce_mean(operand, dims, drop = TRUE)  nv_reduce_prod(operand, dims, drop = TRUE)  nv_reduce_max(operand, dims, drop = TRUE)  nv_reduce_min(operand, dims, drop = TRUE)  nv_reduce_any(operand, dims, drop = TRUE)  nv_reduce_all(operand, dims, drop = TRUE)"},{"path":"/reference/nv_reduce_ops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reduction Operators — nv_reduce_ops","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"/reference/nv_reduce_ops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reduction Operators — nv_reduce_ops","text":"tensorish","code":""},{"path":"/reference/nv_remainder.html","id":null,"dir":"Reference","previous_headings":"","what":"Remainder — nv_remainder","title":"Remainder — nv_remainder","text":"Element-wise remainder division.","code":""},{"path":"/reference/nv_remainder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remainder — nv_remainder","text":"","code":"nv_remainder(lhs, rhs)"},{"path":"/reference/nv_remainder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remainder — nv_remainder","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_remainder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remainder — nv_remainder","text":"tensorish","code":""},{"path":"/reference/nv_reshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshape — nv_reshape","title":"Reshape — nv_reshape","text":"Reshape tensor. Note row-major order used, differs R's column-major order.","code":""},{"path":"/reference/nv_reshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshape — nv_reshape","text":"","code":"nv_reshape(operand, shape)"},{"path":"/reference/nv_reshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshape — nv_reshape","text":"operand (tensorish) Operand. shape (integer()) new shape.","code":""},{"path":"/reference/nv_reshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshape — nv_reshape","text":"tensorish","code":""},{"path":"/reference/nv_reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse — nv_reverse","title":"Reverse — nv_reverse","text":"Reverses order elements along specified dimensions.","code":""},{"path":"/reference/nv_reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse — nv_reverse","text":"","code":"nv_reverse(operand, dims)"},{"path":"/reference/nv_reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse — nv_reverse","text":"operand (tensorish) Operand. dims (integer()) Dimensions reverse.","code":""},{"path":"/reference/nv_reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse — nv_reverse","text":"tensorish","code":""},{"path":"/reference/nv_rng_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random state — nv_rng_state","title":"Generate random state — nv_rng_state","text":"lightweight function generate initial state","code":""},{"path":"/reference/nv_rng_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random state — nv_rng_state","text":"","code":"nv_rng_state(seed)"},{"path":"/reference/nv_rng_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random state — nv_rng_state","text":"seed (integer(1)) Seed value","code":""},{"path":"/reference/nv_rng_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random state — nv_rng_state","text":"nv_tensor dtype ui64 shape (2)","code":""},{"path":"/reference/nv_rnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Normal Distribution — nv_rnorm","title":"Sample from a Normal Distribution — nv_rnorm","text":"Sample normal distribution mean \\(\\mu\\) standard deviation \\(\\sigma\\).","code":""},{"path":"/reference/nv_rnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Normal Distribution — nv_rnorm","text":"","code":"nv_rnorm(shape, initial_state, dtype = \"f32\", mu = 0, sigma = 1)"},{"path":"/reference/nv_rnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Normal Distribution — nv_rnorm","text":"shape (integer()) Shape. initial_state ([ui64[2]][tensorish]) RNG state. dtype (character(1) | stablehlo::TensorDataType) Data type. mu (numeric(1)) Expected value. sigma (numeric(1)) Standard deviation.","code":""},{"path":"/reference/nv_rnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Normal Distribution — nv_rnorm","text":"(list() tensorish) List two tensors: new RNG state generated random numbers.","code":""},{"path":"/reference/nv_rnorm.html","id":"covariance","dir":"Reference","previous_headings":"","what":"Covariance","title":"Sample from a Normal Distribution — nv_rnorm","text":"implement covariance structure use cholesky decomposition.","code":""},{"path":"/reference/nv_round.html","id":null,"dir":"Reference","previous_headings":"","what":"Round — nv_round","title":"Round — nv_round","text":"Element-wise rounding.","code":""},{"path":"/reference/nv_round.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Round — nv_round","text":"","code":"nv_round(operand, method = \"nearest_even\")"},{"path":"/reference/nv_round.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Round — nv_round","text":"operand (tensorish) Operand. method (character(1)) Method use rounding. Either \"nearest_even\" (default) \"afz\" (away zero).","code":""},{"path":"/reference/nv_round.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Round — nv_round","text":"tensorish","code":""},{"path":"/reference/nv_rsqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Reciprocal Square Root — nv_rsqrt","title":"Reciprocal Square Root — nv_rsqrt","text":"Element-wise reciprocal square root.","code":""},{"path":"/reference/nv_rsqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reciprocal Square Root — nv_rsqrt","text":"","code":"nv_rsqrt(operand)"},{"path":"/reference/nv_rsqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reciprocal Square Root — nv_rsqrt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_rsqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reciprocal Square Root — nv_rsqrt","text":"tensorish","code":""},{"path":"/reference/nv_runif.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal: Random Unit Uniform Numbers — nv_runif","title":"Internal: Random Unit Uniform Numbers — nv_runif","text":"generate random uniform numbers [0, 1) Sample uniform distribution open interval (lower, upper).","code":""},{"path":"/reference/nv_runif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal: Random Unit Uniform Numbers — nv_runif","text":"","code":"nv_unif_rand(shape, initial_state, dtype = \"f64\")  nv_runif(shape, initial_state, dtype = \"f32\", lower = 0, upper = 1)"},{"path":"/reference/nv_runif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal: Random Unit Uniform Numbers — nv_runif","text":"shape (integer()) Shape. initial_state ([ui64[2]][tensorish]) RNG state. dtype (character(1) | stablehlo::TensorDataType) Data type. lower, upper (numeric(1)) Lower upper bound.","code":""},{"path":"/reference/nv_runif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal: Random Unit Uniform Numbers — nv_runif","text":"(list() tensorish) List two tensors: new RNG state generated random numbers.","code":""},{"path":"/reference/nv_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Select — nv_select","title":"Select — nv_select","text":"return values true_value false_value conditioned pred","code":""},{"path":"/reference/nv_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select — nv_select","text":"","code":"nv_select(pred, true_value, false_value)"},{"path":"/reference/nv_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select — nv_select","text":"pred condition true_value true false_value false","code":""},{"path":"/reference/nv_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select — nv_select","text":"tensorish","code":""},{"path":"/reference/nv_shift_left.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift Left — nv_shift_left","title":"Shift Left — nv_shift_left","text":"Element-wise bitwise left shift.","code":""},{"path":"/reference/nv_shift_left.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift Left — nv_shift_left","text":"","code":"nv_shift_left(lhs, rhs)"},{"path":"/reference/nv_shift_left.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift Left — nv_shift_left","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_shift_left.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift Left — nv_shift_left","text":"tensorish","code":""},{"path":"/reference/nv_shift_right_arithmetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Shift Right — nv_shift_right_arithmetic","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"Element-wise bitwise arithmetic right shift.","code":""},{"path":"/reference/nv_shift_right_arithmetic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"","code":"nv_shift_right_arithmetic(lhs, rhs)"},{"path":"/reference/nv_shift_right_arithmetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_shift_right_arithmetic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Shift Right — nv_shift_right_arithmetic","text":"tensorish","code":""},{"path":"/reference/nv_shift_right_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Shift Right — nv_shift_right_logical","title":"Logical Shift Right — nv_shift_right_logical","text":"Element-wise bitwise logical right shift.","code":""},{"path":"/reference/nv_shift_right_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Shift Right — nv_shift_right_logical","text":"","code":"nv_shift_right_logical(lhs, rhs)"},{"path":"/reference/nv_shift_right_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Shift Right — nv_shift_right_logical","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_shift_right_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Shift Right — nv_shift_right_logical","text":"tensorish","code":""},{"path":"/reference/nv_sign.html","id":null,"dir":"Reference","previous_headings":"","what":"Sign — nv_sign","title":"Sign — nv_sign","text":"Element-wise sign function.","code":""},{"path":"/reference/nv_sign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sign — nv_sign","text":"","code":"nv_sign(operand)"},{"path":"/reference/nv_sign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sign — nv_sign","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_sign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sign — nv_sign","text":"tensorish","code":""},{"path":"/reference/nv_sine.html","id":null,"dir":"Reference","previous_headings":"","what":"Sine — nv_sine","title":"Sine — nv_sine","text":"Element-wise sine.","code":""},{"path":"/reference/nv_sine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sine — nv_sine","text":"","code":"nv_sine(operand)"},{"path":"/reference/nv_sine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sine — nv_sine","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_sine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sine — nv_sine","text":"tensorish","code":""},{"path":"/reference/nv_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice — nv_slice","title":"Slice — nv_slice","text":"return slice operand.","code":""},{"path":"/reference/nv_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice — nv_slice","text":"","code":"nv_slice(operand, start_indices, limit_indices, strides)"},{"path":"/reference/nv_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice — nv_slice","text":"operand (tensorish) Operand. start_indices start slice limit_indices end slice strides stride size","code":""},{"path":"/reference/nv_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice — nv_slice","text":"tensorish","code":""},{"path":"/reference/nv_sqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Square Root — nv_sqrt","title":"Square Root — nv_sqrt","text":"Element-wise square root.","code":""},{"path":"/reference/nv_sqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Square Root — nv_sqrt","text":"","code":"nv_sqrt(operand)"},{"path":"/reference/nv_sqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Square Root — nv_sqrt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_sqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Square Root — nv_sqrt","text":"tensorish","code":""},{"path":"/reference/nv_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"Subtraction — nv_sub","title":"Subtraction — nv_sub","text":"Element-wise subtraction two tensors.","code":""},{"path":"/reference/nv_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subtraction — nv_sub","text":"","code":"nv_sub(lhs, rhs)"},{"path":"/reference/nv_sub.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subtraction — nv_sub","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subtraction — nv_sub","text":"tensorish","code":""},{"path":"/reference/nv_tan.html","id":null,"dir":"Reference","previous_headings":"","what":"Tangent — nv_tan","title":"Tangent — nv_tan","text":"Element-wise tangent.","code":""},{"path":"/reference/nv_tan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tangent — nv_tan","text":"","code":"nv_tan(operand)"},{"path":"/reference/nv_tan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tangent — nv_tan","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_tan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tangent — nv_tan","text":"tensorish","code":""},{"path":"/reference/nv_tanh.html","id":null,"dir":"Reference","previous_headings":"","what":"Hyperbolic Tangent — nv_tanh","title":"Hyperbolic Tangent — nv_tanh","text":"Element-wise hyperbolic tangent.","code":""},{"path":"/reference/nv_tanh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hyperbolic Tangent — nv_tanh","text":"","code":"nv_tanh(operand)"},{"path":"/reference/nv_tanh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hyperbolic Tangent — nv_tanh","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nv_tanh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hyperbolic Tangent — nv_tanh","text":"tensorish","code":""},{"path":"/reference/nv_tensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Tensor — AnvilTensor","title":"Tensor — AnvilTensor","text":"Create tensor.","code":""},{"path":"/reference/nv_tensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tensor — AnvilTensor","text":"","code":"AnvilTensor  nv_tensor(data, dtype = NULL, device = NULL, shape = NULL)  nv_scalar(data, dtype = NULL, device = NULL)  nv_empty(dtype, shape, device = NULL)"},{"path":"/reference/nv_tensor.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Tensor — AnvilTensor","text":"object class S7_S3_class length 3.","code":""},{"path":"/reference/nv_tensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tensor — AnvilTensor","text":"data () Object convertible PJRTBuffer. dtype (NULL | character(1) | stablehlo::TensorDataType) One pred, i8, i16, i32, i64, ui8, ui16, ui32, ui64, f32, f64 stablehlo::TensorDataType. default (NULL) uses f32 numeric data, i32 integer data, pred logical data. device (NULL | character(1) | PJRTDevice) platform name tensor (\"cpu\", \"cuda\", \"metal\"). Default use CPU, unless data already PJRTBuffer. can change default setting PJRT_PLATFORM environment variable. shape (NULL | integer()) Shape. default (NULL) infer data possible. Note nv_tensor interprets length 1 vectors shape (1). create \"scalar\" dimension (), use nv_scalar.","code":""},{"path":"/reference/nv_tensor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tensor — AnvilTensor","text":"(AnvilTensor)","code":""},{"path":"/reference/nv_tensor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tensor — AnvilTensor","text":"Internally calls pjrt_buffer.","code":""},{"path":"/reference/nv_transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose — nv_transpose","title":"Transpose — nv_transpose","text":"Transpose tensor.","code":""},{"path":"/reference/nv_transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose — nv_transpose","text":"","code":"nv_transpose(x, permutation = NULL)  # S3 method for class '`anvil::Box`' t(x)"},{"path":"/reference/nv_transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose — nv_transpose","text":"x (nv_tensor) permutation (integer() | NULl) Permutation dimensions. NULL (default), reverses dimensions.","code":""},{"path":"/reference/nv_transpose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose — nv_transpose","text":"nv_tensor","code":""},{"path":"/reference/nv_while.html","id":null,"dir":"Reference","previous_headings":"","what":"While — nv_while","title":"While — nv_while","text":"Functional loop.","code":""},{"path":"/reference/nv_while.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"While — nv_while","text":"","code":"nv_while(init, cond, body)"},{"path":"/reference/nv_while.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"While — nv_while","text":"init (list()) Initial state. cond (function) Condition function: f: state -> bool. body (function) Body function. f: state -> state.","code":""},{"path":"/reference/nv_while.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"While — nv_while","text":"tensorish","code":""},{"path":"/reference/nv_xor.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical Xor — nv_xor","title":"Logical Xor — nv_xor","text":"Element-wise logical XOR operation.","code":""},{"path":"/reference/nv_xor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical Xor — nv_xor","text":"","code":"nv_xor(lhs, rhs)"},{"path":"/reference/nv_xor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical Xor — nv_xor","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nv_xor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical Xor — nv_xor","text":"tensorish","code":""},{"path":"/reference/nvl_abs.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Absolute Value — nvl_abs","title":"Primitive Absolute Value — nvl_abs","text":"Element-wise absolute value.","code":""},{"path":"/reference/nvl_abs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Absolute Value — nvl_abs","text":"","code":"nvl_abs(operand)"},{"path":"/reference/nvl_abs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Absolute Value — nvl_abs","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_abs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Absolute Value — nvl_abs","text":"tensorish","code":""},{"path":"/reference/nvl_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Addition — nvl_add","title":"Primitive Addition — nvl_add","text":"Adds two tensors element-wise.","code":""},{"path":"/reference/nvl_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Addition — nvl_add","text":"","code":"nvl_add(lhs, rhs)"},{"path":"/reference/nvl_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Addition — nvl_add","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Addition — nvl_add","text":"tensorish","code":""},{"path":"/reference/nvl_and.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive And — nvl_and","title":"Primitive And — nvl_and","text":"Element-wise logical .","code":""},{"path":"/reference/nvl_and.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive And — nvl_and","text":"","code":"nvl_and(lhs, rhs)"},{"path":"/reference/nvl_and.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive And — nvl_and","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_and.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive And — nvl_and","text":"tensorish","code":""},{"path":"/reference/nvl_atan2.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Atan2 — nvl_atan2","title":"Primitive Atan2 — nvl_atan2","text":"Element-wise atan2 operation.","code":""},{"path":"/reference/nvl_atan2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Atan2 — nvl_atan2","text":"","code":"nvl_atan2(lhs, rhs)"},{"path":"/reference/nvl_atan2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Atan2 — nvl_atan2","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_atan2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Atan2 — nvl_atan2","text":"tensorish","code":""},{"path":"/reference/nvl_bitcast_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Bitcast Convert — nvl_bitcast_convert","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"Reinterprets tensor bits different dtype.","code":""},{"path":"/reference/nvl_bitcast_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"","code":"nvl_bitcast_convert(operand, dtype)"},{"path":"/reference/nvl_bitcast_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"operand (tensorish) Operand. dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"/reference/nvl_bitcast_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Bitcast Convert — nvl_bitcast_convert","text":"tensorish","code":""},{"path":"/reference/nvl_broadcast_in_dim.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Broadcast — nvl_broadcast_in_dim","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"Broadcasts tensor new shape.","code":""},{"path":"/reference/nvl_broadcast_in_dim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"","code":"nvl_broadcast_in_dim(operand, shape_out, broadcast_dimensions)"},{"path":"/reference/nvl_broadcast_in_dim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"operand (tensorish) Operand. shape_out (integer()) Target shape. broadcast_dimensions (integer()) Dimension mapping.","code":""},{"path":"/reference/nvl_broadcast_in_dim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Broadcast — nvl_broadcast_in_dim","text":"tensorish","code":""},{"path":"/reference/nvl_cbrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Cube Root — nvl_cbrt","title":"Primitive Cube Root — nvl_cbrt","text":"Element-wise cube root.","code":""},{"path":"/reference/nvl_cbrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Cube Root — nvl_cbrt","text":"","code":"nvl_cbrt(operand)"},{"path":"/reference/nvl_cbrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Cube Root — nvl_cbrt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_cbrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Cube Root — nvl_cbrt","text":"tensorish","code":""},{"path":"/reference/nvl_ceil.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Ceiling — nvl_ceil","title":"Primitive Ceiling — nvl_ceil","text":"Element-wise ceiling.","code":""},{"path":"/reference/nvl_ceil.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Ceiling — nvl_ceil","text":"","code":"nvl_ceil(operand)"},{"path":"/reference/nvl_ceil.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Ceiling — nvl_ceil","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_ceil.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Ceiling — nvl_ceil","text":"tensorish","code":""},{"path":"/reference/nvl_clamp.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Clamp — nvl_clamp","title":"Primitive Clamp — nvl_clamp","text":"Element-wise clamp: max(min_val, min(operand, max_val)).","code":""},{"path":"/reference/nvl_clamp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Clamp — nvl_clamp","text":"","code":"nvl_clamp(min_val, operand, max_val)"},{"path":"/reference/nvl_clamp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Clamp — nvl_clamp","text":"min_val (tensorish) Minimum value (scalar shape operand). operand (tensorish) Operand. max_val (tensorish) Maximum value (scalar shape operand).","code":""},{"path":"/reference/nvl_clamp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Clamp — nvl_clamp","text":"tensorish","code":""},{"path":"/reference/nvl_concatenate.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Concatenate — nvl_concatenate","title":"Primitive Concatenate — nvl_concatenate","text":"Concatenates tensors along dimension.","code":""},{"path":"/reference/nvl_concatenate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Concatenate — nvl_concatenate","text":"","code":"nvl_concatenate(..., dimension)"},{"path":"/reference/nvl_concatenate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Concatenate — nvl_concatenate","text":"... (tensorish) Tensors concatenate. dimension (integer(1)) Dimension concatenate along.","code":""},{"path":"/reference/nvl_concatenate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Concatenate — nvl_concatenate","text":"tensorish","code":""},{"path":"/reference/nvl_convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Convert — nvl_convert","title":"Primitive Convert — nvl_convert","text":"Converts tensor different dtype.","code":""},{"path":"/reference/nvl_convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Convert — nvl_convert","text":"","code":"nvl_convert(operand, dtype, ambiguous = FALSE)"},{"path":"/reference/nvl_convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Convert — nvl_convert","text":"operand (tensorish) Operand. dtype (character(1) | stablehlo::TensorDataType) Data type. ambiguous (logical(1)) Whether type ambiguous. Ambiguous types usually arise R literals (e.g., 1L, 1.0) follow special promotion rules. See vignette \"Type Promotion\" details.","code":""},{"path":"/reference/nvl_convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Convert — nvl_convert","text":"tensorish","code":""},{"path":"/reference/nvl_cosine.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Cosine — nvl_cosine","title":"Primitive Cosine — nvl_cosine","text":"Element-wise cosine.","code":""},{"path":"/reference/nvl_cosine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Cosine — nvl_cosine","text":"","code":"nvl_cosine(operand)"},{"path":"/reference/nvl_cosine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Cosine — nvl_cosine","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_cosine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Cosine — nvl_cosine","text":"tensorish","code":""},{"path":"/reference/nvl_div.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Division — nvl_div","title":"Primitive Division — nvl_div","text":"Divides two tensors element-wise.","code":""},{"path":"/reference/nvl_div.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Division — nvl_div","text":"","code":"nvl_div(lhs, rhs)"},{"path":"/reference/nvl_div.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Division — nvl_div","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_div.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Division — nvl_div","text":"tensorish","code":""},{"path":"/reference/nvl_dot_general.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Dot General — nvl_dot_general","title":"Primitive Dot General — nvl_dot_general","text":"General dot product two tensors.","code":""},{"path":"/reference/nvl_dot_general.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Dot General — nvl_dot_general","text":"","code":"nvl_dot_general(lhs, rhs, contracting_dims, batching_dims)"},{"path":"/reference/nvl_dot_general.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Dot General — nvl_dot_general","text":"lhs, rhs (tensorish) Left right operand. contracting_dims (list()) Dimensions contract. batching_dims (list()) Batch dimensions.","code":""},{"path":"/reference/nvl_dot_general.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Dot General — nvl_dot_general","text":"tensorish","code":""},{"path":"/reference/nvl_eq.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Equal — nvl_eq","title":"Primitive Equal — nvl_eq","text":"Element-wise equality comparison.","code":""},{"path":"/reference/nvl_eq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Equal — nvl_eq","text":"","code":"nvl_eq(lhs, rhs)"},{"path":"/reference/nvl_eq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Equal — nvl_eq","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_eq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Equal — nvl_eq","text":"tensorish (boolean)","code":""},{"path":"/reference/nvl_exp.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Exponential — nvl_exp","title":"Primitive Exponential — nvl_exp","text":"Element-wise exponential.","code":""},{"path":"/reference/nvl_exp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Exponential — nvl_exp","text":"","code":"nvl_exp(operand)"},{"path":"/reference/nvl_exp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Exponential — nvl_exp","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_exp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Exponential — nvl_exp","text":"tensorish","code":""},{"path":"/reference/nvl_expm1.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Exponential Minus One — nvl_expm1","title":"Primitive Exponential Minus One — nvl_expm1","text":"Element-wise exp(x) - 1, accurate small x.","code":""},{"path":"/reference/nvl_expm1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Exponential Minus One — nvl_expm1","text":"","code":"nvl_expm1(operand)"},{"path":"/reference/nvl_expm1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Exponential Minus One — nvl_expm1","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_expm1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Exponential Minus One — nvl_expm1","text":"tensorish","code":""},{"path":"/reference/nvl_fill.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Fill — nvl_fill","title":"Primitive Fill — nvl_fill","text":"Creates tensor filled scalar value.","code":""},{"path":"/reference/nvl_fill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Fill — nvl_fill","text":"","code":"nvl_fill(value, shape, dtype)"},{"path":"/reference/nvl_fill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Fill — nvl_fill","text":"value (numeric(1)) Scalar value. shape (integer()) Shape. dtype (character(1) | stablehlo::TensorDataType) Data type.","code":""},{"path":"/reference/nvl_fill.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Fill — nvl_fill","text":"tensorish","code":""},{"path":"/reference/nvl_floor.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Floor — nvl_floor","title":"Primitive Floor — nvl_floor","text":"Element-wise floor.","code":""},{"path":"/reference/nvl_floor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Floor — nvl_floor","text":"","code":"nvl_floor(operand)"},{"path":"/reference/nvl_floor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Floor — nvl_floor","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_floor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Floor — nvl_floor","text":"tensorish","code":""},{"path":"/reference/nvl_ge.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Greater Equal — nvl_ge","title":"Primitive Greater Equal — nvl_ge","text":"Element-wise greater equal comparison.","code":""},{"path":"/reference/nvl_ge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Greater Equal — nvl_ge","text":"","code":"nvl_ge(lhs, rhs)"},{"path":"/reference/nvl_ge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Greater Equal — nvl_ge","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_ge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Greater Equal — nvl_ge","text":"tensorish (boolean)","code":""},{"path":"/reference/nvl_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Greater Than — nvl_gt","title":"Primitive Greater Than — nvl_gt","text":"Element-wise greater comparison.","code":""},{"path":"/reference/nvl_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Greater Than — nvl_gt","text":"","code":"nvl_gt(lhs, rhs)"},{"path":"/reference/nvl_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Greater Than — nvl_gt","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Greater Than — nvl_gt","text":"tensorish (boolean)","code":""},{"path":"/reference/nvl_if.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive If — nvl_if","title":"Primitive If — nvl_if","text":"Conditional execution branches.","code":""},{"path":"/reference/nvl_if.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive If — nvl_if","text":"","code":"nvl_if(pred, true, false)"},{"path":"/reference/nvl_if.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive If — nvl_if","text":"pred (tensorish) Scalar boolean predicate. true (expression) Expression true branch. false (expression) Expression false branch.","code":""},{"path":"/reference/nvl_if.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive If — nvl_if","text":"Result executed branch.","code":""},{"path":"/reference/nvl_iota.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Iota — nvl_iota","title":"Primitive Iota — nvl_iota","text":"Creates tensor values increasing along specified dimension.","code":""},{"path":"/reference/nvl_iota.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Iota — nvl_iota","text":"","code":"nvl_iota(dim, dtype, shape)"},{"path":"/reference/nvl_iota.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Iota — nvl_iota","text":"dim (integer(1)) Dimension along values increase (1-indexed). dtype (character(1) | stablehlo::TensorDataType) Data type. shape (integer()) Shape output tensor.","code":""},{"path":"/reference/nvl_iota.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Iota — nvl_iota","text":"tensorish","code":""},{"path":"/reference/nvl_is_finite.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Is Finite — nvl_is_finite","title":"Primitive Is Finite — nvl_is_finite","text":"Element-wise check values finite (Inf, -Inf, NaN).","code":""},{"path":"/reference/nvl_is_finite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Is Finite — nvl_is_finite","text":"","code":"nvl_is_finite(operand)"},{"path":"/reference/nvl_is_finite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Is Finite — nvl_is_finite","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_is_finite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Is Finite — nvl_is_finite","text":"tensorish boolean type","code":""},{"path":"/reference/nvl_le.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Less Equal — nvl_le","title":"Primitive Less Equal — nvl_le","text":"Element-wise less equal comparison.","code":""},{"path":"/reference/nvl_le.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Less Equal — nvl_le","text":"","code":"nvl_le(lhs, rhs)"},{"path":"/reference/nvl_le.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Less Equal — nvl_le","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_le.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Less Equal — nvl_le","text":"tensorish (boolean)","code":""},{"path":"/reference/nvl_log.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Logarithm — nvl_log","title":"Primitive Logarithm — nvl_log","text":"Element-wise natural logarithm.","code":""},{"path":"/reference/nvl_log.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Logarithm — nvl_log","text":"","code":"nvl_log(operand)"},{"path":"/reference/nvl_log.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Logarithm — nvl_log","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_log.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Logarithm — nvl_log","text":"tensorish","code":""},{"path":"/reference/nvl_log1p.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Log Plus One — nvl_log1p","title":"Primitive Log Plus One — nvl_log1p","text":"Element-wise log(1 + x), accurate small x.","code":""},{"path":"/reference/nvl_log1p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Log Plus One — nvl_log1p","text":"","code":"nvl_log1p(operand)"},{"path":"/reference/nvl_log1p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Log Plus One — nvl_log1p","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_log1p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Log Plus One — nvl_log1p","text":"tensorish","code":""},{"path":"/reference/nvl_logistic.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Logistic (Sigmoid) — nvl_logistic","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"Element-wise logistic sigmoid: 1 / (1 + exp(-x)).","code":""},{"path":"/reference/nvl_logistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"","code":"nvl_logistic(operand)"},{"path":"/reference/nvl_logistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_logistic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Logistic (Sigmoid) — nvl_logistic","text":"tensorish","code":""},{"path":"/reference/nvl_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Less Than — nvl_lt","title":"Primitive Less Than — nvl_lt","text":"Element-wise less comparison.","code":""},{"path":"/reference/nvl_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Less Than — nvl_lt","text":"","code":"nvl_lt(lhs, rhs)"},{"path":"/reference/nvl_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Less Than — nvl_lt","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Less Than — nvl_lt","text":"tensorish (boolean)","code":""},{"path":"/reference/nvl_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Maximum — nvl_max","title":"Primitive Maximum — nvl_max","text":"Element-wise maximum two tensors.","code":""},{"path":"/reference/nvl_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Maximum — nvl_max","text":"","code":"nvl_max(lhs, rhs)"},{"path":"/reference/nvl_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Maximum — nvl_max","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Maximum — nvl_max","text":"tensorish","code":""},{"path":"/reference/nvl_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Minimum — nvl_min","title":"Primitive Minimum — nvl_min","text":"Element-wise minimum two tensors.","code":""},{"path":"/reference/nvl_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Minimum — nvl_min","text":"","code":"nvl_min(lhs, rhs)"},{"path":"/reference/nvl_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Minimum — nvl_min","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Minimum — nvl_min","text":"tensorish","code":""},{"path":"/reference/nvl_mul.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Multiplication — nvl_mul","title":"Primitive Multiplication — nvl_mul","text":"Multiplies two tensors element-wise.","code":""},{"path":"/reference/nvl_mul.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Multiplication — nvl_mul","text":"","code":"nvl_mul(lhs, rhs)"},{"path":"/reference/nvl_mul.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Multiplication — nvl_mul","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_mul.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Multiplication — nvl_mul","text":"tensorish","code":""},{"path":"/reference/nvl_ne.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Not Equal — nvl_ne","title":"Primitive Not Equal — nvl_ne","text":"Element-wise inequality comparison.","code":""},{"path":"/reference/nvl_ne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Not Equal — nvl_ne","text":"","code":"nvl_ne(lhs, rhs)"},{"path":"/reference/nvl_ne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Not Equal — nvl_ne","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_ne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Not Equal — nvl_ne","text":"tensorish (boolean)","code":""},{"path":"/reference/nvl_neg.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Negation — nvl_neg","title":"Primitive Negation — nvl_neg","text":"Negates tensor element-wise.","code":""},{"path":"/reference/nvl_neg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Negation — nvl_neg","text":"","code":"nvl_neg(operand)"},{"path":"/reference/nvl_neg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Negation — nvl_neg","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_neg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Negation — nvl_neg","text":"tensorish","code":""},{"path":"/reference/nvl_not.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Not — nvl_not","title":"Primitive Not — nvl_not","text":"Element-wise logical .","code":""},{"path":"/reference/nvl_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Not — nvl_not","text":"","code":"nvl_not(operand)"},{"path":"/reference/nvl_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Not — nvl_not","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Not — nvl_not","text":"tensorish","code":""},{"path":"/reference/nvl_or.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Or — nvl_or","title":"Primitive Or — nvl_or","text":"Element-wise logical .","code":""},{"path":"/reference/nvl_or.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Or — nvl_or","text":"","code":"nvl_or(lhs, rhs)"},{"path":"/reference/nvl_or.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Or — nvl_or","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_or.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Or — nvl_or","text":"tensorish","code":""},{"path":"/reference/nvl_pad.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Pad — nvl_pad","title":"Primitive Pad — nvl_pad","text":"Pads tensor given padding value.","code":""},{"path":"/reference/nvl_pad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Pad — nvl_pad","text":"","code":"nvl_pad(   operand,   padding_value,   edge_padding_low,   edge_padding_high,   interior_padding )"},{"path":"/reference/nvl_pad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Pad — nvl_pad","text":"operand (tensorish) Operand. padding_value (tensorish) Scalar value use padding. edge_padding_low (integer()) Amount padding add start dimension. edge_padding_high (integer()) Amount padding add end dimension. interior_padding (integer()) Amount padding add elements dimension.","code":""},{"path":"/reference/nvl_pad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Pad — nvl_pad","text":"tensorish","code":""},{"path":"/reference/nvl_popcnt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Population Count — nvl_popcnt","title":"Primitive Population Count — nvl_popcnt","text":"Element-wise population count (number set bits).","code":""},{"path":"/reference/nvl_popcnt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Population Count — nvl_popcnt","text":"","code":"nvl_popcnt(operand)"},{"path":"/reference/nvl_popcnt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Population Count — nvl_popcnt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_popcnt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Population Count — nvl_popcnt","text":"tensorish","code":""},{"path":"/reference/nvl_pow.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Power — nvl_pow","title":"Primitive Power — nvl_pow","text":"Raises lhs power rhs element-wise.","code":""},{"path":"/reference/nvl_pow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Power — nvl_pow","text":"","code":"nvl_pow(lhs, rhs)"},{"path":"/reference/nvl_pow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Power — nvl_pow","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_pow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Power — nvl_pow","text":"tensorish","code":""},{"path":"/reference/nvl_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Print — nvl_print","title":"Primitive Print — nvl_print","text":"Prints tensor execution. Returns input unchanged. Note: Currently works CPU backend.","code":""},{"path":"/reference/nvl_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Print — nvl_print","text":"","code":"nvl_print(operand)"},{"path":"/reference/nvl_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Print — nvl_print","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Print — nvl_print","text":"tensorish","code":""},{"path":"/reference/nvl_reduce_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive All Reduction — nvl_reduce_all","title":"Primitive All Reduction — nvl_reduce_all","text":"Logical along dimensions.","code":""},{"path":"/reference/nvl_reduce_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive All Reduction — nvl_reduce_all","text":"","code":"nvl_reduce_all(operand, dims, drop = TRUE)"},{"path":"/reference/nvl_reduce_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive All Reduction — nvl_reduce_all","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"/reference/nvl_reduce_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive All Reduction — nvl_reduce_all","text":"tensorish","code":""},{"path":"/reference/nvl_reduce_any.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Any Reduction — nvl_reduce_any","title":"Primitive Any Reduction — nvl_reduce_any","text":"Logical along dimensions.","code":""},{"path":"/reference/nvl_reduce_any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Any Reduction — nvl_reduce_any","text":"","code":"nvl_reduce_any(operand, dims, drop = TRUE)"},{"path":"/reference/nvl_reduce_any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Any Reduction — nvl_reduce_any","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"/reference/nvl_reduce_any.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Any Reduction — nvl_reduce_any","text":"tensorish","code":""},{"path":"/reference/nvl_reduce_max.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Max Reduction — nvl_reduce_max","title":"Primitive Max Reduction — nvl_reduce_max","text":"Finds maximum along dimensions.","code":""},{"path":"/reference/nvl_reduce_max.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Max Reduction — nvl_reduce_max","text":"","code":"nvl_reduce_max(operand, dims, drop = TRUE)"},{"path":"/reference/nvl_reduce_max.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Max Reduction — nvl_reduce_max","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"/reference/nvl_reduce_max.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Max Reduction — nvl_reduce_max","text":"tensorish","code":""},{"path":"/reference/nvl_reduce_min.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Min Reduction — nvl_reduce_min","title":"Primitive Min Reduction — nvl_reduce_min","text":"Finds minimum along dimensions.","code":""},{"path":"/reference/nvl_reduce_min.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Min Reduction — nvl_reduce_min","text":"","code":"nvl_reduce_min(operand, dims, drop = TRUE)"},{"path":"/reference/nvl_reduce_min.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Min Reduction — nvl_reduce_min","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"/reference/nvl_reduce_min.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Min Reduction — nvl_reduce_min","text":"tensorish","code":""},{"path":"/reference/nvl_reduce_prod.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Product Reduction — nvl_reduce_prod","title":"Primitive Product Reduction — nvl_reduce_prod","text":"Multiplies tensor elements along dimensions.","code":""},{"path":"/reference/nvl_reduce_prod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Product Reduction — nvl_reduce_prod","text":"","code":"nvl_reduce_prod(operand, dims, drop = TRUE)"},{"path":"/reference/nvl_reduce_prod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Product Reduction — nvl_reduce_prod","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"/reference/nvl_reduce_prod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Product Reduction — nvl_reduce_prod","text":"tensorish","code":""},{"path":"/reference/nvl_reduce_sum.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Sum Reduction — nvl_reduce_sum","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"Sums tensor elements along dimensions.","code":""},{"path":"/reference/nvl_reduce_sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"","code":"nvl_reduce_sum(operand, dims, drop = TRUE)"},{"path":"/reference/nvl_reduce_sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"operand (tensorish) Operand. dims (integer()) Dimensions reduce. drop (logical(1)) Whether drop reduced dimensions.","code":""},{"path":"/reference/nvl_reduce_sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Sum Reduction — nvl_reduce_sum","text":"tensorish","code":""},{"path":"/reference/nvl_remainder.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Remainder — nvl_remainder","title":"Primitive Remainder — nvl_remainder","text":"Element-wise remainder division.","code":""},{"path":"/reference/nvl_remainder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Remainder — nvl_remainder","text":"","code":"nvl_remainder(lhs, rhs)"},{"path":"/reference/nvl_remainder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Remainder — nvl_remainder","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_remainder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Remainder — nvl_remainder","text":"tensorish","code":""},{"path":"/reference/nvl_reshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Reshape — nvl_reshape","title":"Primitive Reshape — nvl_reshape","text":"Reshapes tensor new shape.","code":""},{"path":"/reference/nvl_reshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Reshape — nvl_reshape","text":"","code":"nvl_reshape(operand, shape)"},{"path":"/reference/nvl_reshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Reshape — nvl_reshape","text":"operand (tensorish) Operand. shape (integer()) Shape.","code":""},{"path":"/reference/nvl_reshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Reshape — nvl_reshape","text":"tensorish","code":""},{"path":"/reference/nvl_reverse.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Reverse — nvl_reverse","title":"Primitive Reverse — nvl_reverse","text":"Reverses order elements along specified dimensions.","code":""},{"path":"/reference/nvl_reverse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Reverse — nvl_reverse","text":"","code":"nvl_reverse(operand, dims)"},{"path":"/reference/nvl_reverse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Reverse — nvl_reverse","text":"operand (tensorish) Operand. dims (integer()) Dimensions reverse (1-indexed).","code":""},{"path":"/reference/nvl_reverse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Reverse — nvl_reverse","text":"tensorish","code":""},{"path":"/reference/nvl_rng_bit_generator.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive RNG Bit Generator — nvl_rng_bit_generator","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"Generates random bits using specified algorithm.","code":""},{"path":"/reference/nvl_rng_bit_generator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"","code":"nvl_rng_bit_generator(   initial_state,   rng_algorithm = \"THREE_FRY\",   dtype,   shape_out )"},{"path":"/reference/nvl_rng_bit_generator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"initial_state (tensorish) RNG state tensor. rng_algorithm (character(1)) Algorithm name (default \"THREE_FRY\"). dtype (character(1) | stablehlo::TensorDataType) Data type. shape_out (integer()) Output shape.","code":""},{"path":"/reference/nvl_rng_bit_generator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive RNG Bit Generator — nvl_rng_bit_generator","text":"List new state random tensor.","code":""},{"path":"/reference/nvl_round.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Round — nvl_round","title":"Primitive Round — nvl_round","text":"Element-wise rounding.","code":""},{"path":"/reference/nvl_round.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Round — nvl_round","text":"","code":"nvl_round(operand, method = \"nearest_even\")"},{"path":"/reference/nvl_round.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Round — nvl_round","text":"operand (tensorish) Operand. method (character(1)) Rounding method (\"nearest_even\" \"afz\").","code":""},{"path":"/reference/nvl_round.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Round — nvl_round","text":"tensorish","code":""},{"path":"/reference/nvl_rsqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Reciprocal Square Root — nvl_rsqrt","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"Element-wise reciprocal square root.","code":""},{"path":"/reference/nvl_rsqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"","code":"nvl_rsqrt(operand)"},{"path":"/reference/nvl_rsqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_rsqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Reciprocal Square Root — nvl_rsqrt","text":"tensorish","code":""},{"path":"/reference/nvl_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Select — nvl_select","title":"Primitive Select — nvl_select","text":"Selects elements based predicate.","code":""},{"path":"/reference/nvl_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Select — nvl_select","text":"","code":"nvl_select(pred, true_value, false_value)"},{"path":"/reference/nvl_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Select — nvl_select","text":"pred (tensorish) Boolean predicate tensor. true_value (tensorish) Value pred true. false_value (tensorish) Value pred false.","code":""},{"path":"/reference/nvl_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Select — nvl_select","text":"tensorish","code":""},{"path":"/reference/nvl_shift_left.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Shift Left — nvl_shift_left","title":"Primitive Shift Left — nvl_shift_left","text":"Element-wise left bit shift.","code":""},{"path":"/reference/nvl_shift_left.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Shift Left — nvl_shift_left","text":"","code":"nvl_shift_left(lhs, rhs)"},{"path":"/reference/nvl_shift_left.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Shift Left — nvl_shift_left","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_shift_left.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Shift Left — nvl_shift_left","text":"tensorish","code":""},{"path":"/reference/nvl_shift_right_arithmetic.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"Element-wise arithmetic right bit shift.","code":""},{"path":"/reference/nvl_shift_right_arithmetic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"","code":"nvl_shift_right_arithmetic(lhs, rhs)"},{"path":"/reference/nvl_shift_right_arithmetic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_shift_right_arithmetic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Arithmetic Shift Right — nvl_shift_right_arithmetic","text":"tensorish","code":""},{"path":"/reference/nvl_shift_right_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Logical Shift Right — nvl_shift_right_logical","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"Element-wise logical right bit shift.","code":""},{"path":"/reference/nvl_shift_right_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"","code":"nvl_shift_right_logical(lhs, rhs)"},{"path":"/reference/nvl_shift_right_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_shift_right_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Logical Shift Right — nvl_shift_right_logical","text":"tensorish","code":""},{"path":"/reference/nvl_sign.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Sign — nvl_sign","title":"Primitive Sign — nvl_sign","text":"Element-wise sign.","code":""},{"path":"/reference/nvl_sign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Sign — nvl_sign","text":"","code":"nvl_sign(operand)"},{"path":"/reference/nvl_sign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Sign — nvl_sign","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_sign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Sign — nvl_sign","text":"tensorish","code":""},{"path":"/reference/nvl_sine.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Sine — nvl_sine","title":"Primitive Sine — nvl_sine","text":"Element-wise sine.","code":""},{"path":"/reference/nvl_sine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Sine — nvl_sine","text":"","code":"nvl_sine(operand)"},{"path":"/reference/nvl_sine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Sine — nvl_sine","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_sine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Sine — nvl_sine","text":"tensorish","code":""},{"path":"/reference/nvl_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Slice — nvl_slice","title":"Primitive Slice — nvl_slice","text":"Extracts slice tensor.","code":""},{"path":"/reference/nvl_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Slice — nvl_slice","text":"","code":"nvl_slice(operand, start_indices, limit_indices, strides)"},{"path":"/reference/nvl_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Slice — nvl_slice","text":"operand (tensorish) Operand. start_indices (integer()) Start indices (1-based). limit_indices (integer()) End indices (exclusive). strides (integer()) Step sizes.","code":""},{"path":"/reference/nvl_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Slice — nvl_slice","text":"tensorish","code":""},{"path":"/reference/nvl_sqrt.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Square Root — nvl_sqrt","title":"Primitive Square Root — nvl_sqrt","text":"Element-wise square root.","code":""},{"path":"/reference/nvl_sqrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Square Root — nvl_sqrt","text":"","code":"nvl_sqrt(operand)"},{"path":"/reference/nvl_sqrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Square Root — nvl_sqrt","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_sqrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Square Root — nvl_sqrt","text":"tensorish","code":""},{"path":"/reference/nvl_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Subtraction — nvl_sub","title":"Primitive Subtraction — nvl_sub","text":"Subtracts two tensors element-wise.","code":""},{"path":"/reference/nvl_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Subtraction — nvl_sub","text":"","code":"nvl_sub(lhs, rhs)"},{"path":"/reference/nvl_sub.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Subtraction — nvl_sub","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Subtraction — nvl_sub","text":"tensorish","code":""},{"path":"/reference/nvl_tan.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Tangent — nvl_tan","title":"Primitive Tangent — nvl_tan","text":"Element-wise tangent.","code":""},{"path":"/reference/nvl_tan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Tangent — nvl_tan","text":"","code":"nvl_tan(operand)"},{"path":"/reference/nvl_tan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Tangent — nvl_tan","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_tan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Tangent — nvl_tan","text":"tensorish","code":""},{"path":"/reference/nvl_tanh.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Hyperbolic Tangent — nvl_tanh","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"Element-wise hyperbolic tangent.","code":""},{"path":"/reference/nvl_tanh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"","code":"nvl_tanh(operand)"},{"path":"/reference/nvl_tanh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"operand (tensorish) Operand.","code":""},{"path":"/reference/nvl_tanh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Hyperbolic Tangent — nvl_tanh","text":"tensorish","code":""},{"path":"/reference/nvl_transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Transpose — nvl_transpose","title":"Primitive Transpose — nvl_transpose","text":"Transposes tensor according permutation.","code":""},{"path":"/reference/nvl_transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Transpose — nvl_transpose","text":"","code":"nvl_transpose(operand, permutation)"},{"path":"/reference/nvl_transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Transpose — nvl_transpose","text":"operand (tensorish) Operand. permutation (integer()) Dimension permutation.","code":""},{"path":"/reference/nvl_transpose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Transpose — nvl_transpose","text":"tensorish","code":""},{"path":"/reference/nvl_while.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive While Loop — nvl_while","title":"Primitive While Loop — nvl_while","text":"Executes loop.","code":""},{"path":"/reference/nvl_while.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive While Loop — nvl_while","text":"","code":"nvl_while(init, cond, body)"},{"path":"/reference/nvl_while.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive While Loop — nvl_while","text":"init (list()) Named list initial state values. cond (function) Condition function returning boolean. body (function) Body function returning updated state.","code":""},{"path":"/reference/nvl_while.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive While Loop — nvl_while","text":"Final state loop terminates.","code":""},{"path":"/reference/nvl_xor.html","id":null,"dir":"Reference","previous_headings":"","what":"Primitive Xor — nvl_xor","title":"Primitive Xor — nvl_xor","text":"Element-wise logical XOR.","code":""},{"path":"/reference/nvl_xor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Primitive Xor — nvl_xor","text":"","code":"nvl_xor(lhs, rhs)"},{"path":"/reference/nvl_xor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Primitive Xor — nvl_xor","text":"lhs, rhs (tensorish) Left right operand.","code":""},{"path":"/reference/nvl_xor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Primitive Xor — nvl_xor","text":"tensorish","code":""},{"path":"/reference/platform.html","id":null,"dir":"Reference","previous_headings":"","what":"Platform — platform","title":"Platform — platform","text":"Get platform tensor-like object.","code":""},{"path":"/reference/platform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Platform — platform","text":"","code":"platform(x, ...)"},{"path":"/reference/platform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Platform — platform","text":"x () tensor. ... () Additional argument (unused).","code":""},{"path":"/reference/platform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Platform — platform","text":"(character(1))","code":""},{"path":"/reference/prim.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a Primitive — prim","title":"Get a Primitive — prim","text":"Get primitive name.","code":""},{"path":"/reference/prim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a Primitive — prim","text":"","code":"prim(name = NULL)"},{"path":"/reference/prim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a Primitive — prim","text":"name (character() | NULL) name primitive. NULL, returns list primitives.","code":""},{"path":"/reference/prim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a Primitive — prim","text":"(Primitive)","code":""},{"path":"/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. stablehlo as_dtype, is_dtype, Shape tengen as_array, as_raw, device, dtype, ndims, shape","code":""},{"path":"/reference/register_primitive.html","id":null,"dir":"Reference","previous_headings":"","what":"Register a Primitive — register_primitive","title":"Register a Primitive — register_primitive","text":"Register primitive.","code":""},{"path":"/reference/register_primitive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register a Primitive — register_primitive","text":"","code":"register_primitive(name, primitive, overwrite = FALSE)"},{"path":"/reference/register_primitive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register a Primitive — register_primitive","text":"name (character()) name primitive. primitive (Primitive) primitive register. overwrite (logical(1)) Whether overwrite primitive already registered.","code":""},{"path":"/reference/stablehlo.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower a function to StableHLO — stablehlo","title":"Lower a function to StableHLO — stablehlo","text":"Immediately lower flattened function StableHLO Func object.","code":""},{"path":"/reference/stablehlo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower a function to StableHLO — stablehlo","text":"","code":"stablehlo(graph, constants_as_inputs = TRUE, env = NULL, donate = character())"},{"path":"/reference/stablehlo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lower a function to StableHLO — stablehlo","text":"graph (Graph) graph lower. constants_as_inputs (logical(1)) Whether add constants inputs. env (HloEnv | NULL) environment storing graph value func variable mappings. donate (character()) Names arguments whose buffers donated. Donated buffers can aliased outputs type.","code":""},{"path":"/reference/stablehlo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lower a function to StableHLO — stablehlo","text":"(list) elements: func: StableHLO Func object constants: constants graph","code":""},{"path":"/reference/tensorish.html","id":null,"dir":"Reference","previous_headings":"","what":"Tensor-like Objects — tensorish","title":"Tensor-like Objects — tensorish","text":"value either AnvilTensor, can converted , represents abstract version . also includes atomic R vectors.","code":""},{"path":[]},{"path":"/reference/tensorish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tensor-like Objects — tensorish","text":"","code":"x <- nv_tensor(1:4, dtype = \"f32\") x #> AnvilTensor  #>  1.0000 #>  2.0000 #>  3.0000 #>  4.0000 #> [ CPUf32{4} ]"},{"path":"/reference/to_abstract.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to Abstract Tensor — to_abstract","title":"Convert to Abstract Tensor — to_abstract","text":"Convert object abstract tensor representation (AbstractTensor).","code":""},{"path":"/reference/to_abstract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to Abstract Tensor — to_abstract","text":"","code":"to_abstract(x, pure = FALSE)"},{"path":"/reference/to_abstract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to Abstract Tensor — to_abstract","text":"x () Object convert. pure (logical(1)) Whether convert pure abstract tensor, .e., without concrete data.","code":""},{"path":"/reference/to_abstract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to Abstract Tensor — to_abstract","text":"AbstractTensor","code":""},{"path":"/reference/trace_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Trace an R function into a Graph — trace_fn","title":"Trace an R function into a Graph — trace_fn","text":"Create graph representation R function tracing.","code":""},{"path":"/reference/trace_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trace an R function into a Graph — trace_fn","text":"","code":"trace_fn(f, args, desc = NULL)"},{"path":"/reference/trace_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trace an R function into a Graph — trace_fn","text":"f (function) function trace_fn. args (list (AnvilTensor | AbstractTensor)) arguments function. desc (NULL | GraphDescriptor) descriptor use graph.","code":""},{"path":"/reference/trace_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trace an R function into a Graph — trace_fn","text":"(Graph)","code":""},{"path":"/reference/transform_gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a graph to its gradient — transform_gradient","title":"Transform a graph to its gradient — transform_gradient","text":"Transform graph gradient. low-level function usually used directly. Use gradient() instead.","code":""},{"path":"/reference/transform_gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a graph to its gradient — transform_gradient","text":"","code":"transform_gradient(graph, wrt)"},{"path":"/reference/transform_gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a graph to its gradient — transform_gradient","text":"graph (Graph) graph transform. wrt (character) names variables compute gradient respect .","code":""},{"path":"/reference/transform_gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a graph to its gradient — transform_gradient","text":"Graph object.","code":""}]
