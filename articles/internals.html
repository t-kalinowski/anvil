<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Internals • anvil</title>
<!-- mathjax math --><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script><script>
  window.MathJax = {
    chtml: {
      fontURL: "https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/output/chtml/fonts/woff-v2"
    }
  };
</script><script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Internals">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">anvil</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/anvil.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/anvil.html">Get Started</a></li>
    <li><a class="dropdown-item" href="../articles/type-promotion.html">Type Promotion</a></li>
    <li><a class="dropdown-item" href="../articles/primitives.html">Primitives Overview</a></li>
  </ul>
</li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-technical" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Technical</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-technical">
<li><a class="dropdown-item" href="../articles/internals.html">Internals</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-xla/anvil/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Internals</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/r-xla/anvil/blob/quickr/vignettes/internals.Rmd" class="external-link"><code>vignettes/internals.Rmd</code></a></small>
      <div class="d-none name"><code>internals.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="transformations-under-the-hood">Transformations under the Hood<a class="anchor" aria-label="anchor" href="#transformations-under-the-hood"></a>
</h2>
<p>Just like a real anvil, the {anvil} package is a tool that allows you
to reshape objects. While the former is used to shape metal, our {anvil}
package can be used to transform code into other code.</p>
<p>In general, there are three types of transformations:</p>
<ol style="list-style-type: decimal">
<li>
<code>R</code> -&gt; <code>Graph</code>: Generic <code>R</code>
functions are way too complicated to handle, so the first step in
{anvil} is always to convert them into a computational
<code><a href="../reference/Graph.html">anvil::Graph</a></code> object via <strong>tracing</strong>. Such a
<code>Graph</code> is similar to <code>JAXExpr</code> objects in
<code>JAX</code>.</li>
<li>
<code>Graph</code> -&gt; <code>Graph</code>: It is possible to
transform <code>Graph</code>s into other <code>Graph</code>s. Currently,
there is only one such transformation, which is the
<code><a href="../reference/gradient.html">gradient()</a></code> transformation.</li>
<li>
<code>Graph</code> -&gt; <code>Executable</code>: In order to
perform the actual computation, the <code>Graph</code> needs to be
converted into an executable. Currently, we only support the XLA backend
(via <code>stablehlo</code> and <code>pjrt</code>), but it is in
principle possible to support other backends as well.</li>
</ol>
<div class="section level3">
<h3 id="tracing-r-functions-into-graphs">Tracing R functions into Graphs<a class="anchor" aria-label="anchor" href="#tracing-r-functions-into-graphs"></a>
</h3>
<p>All functionality in the {anvil} package is centered around the
<code>Graph</code> class, and such <code>Graph</code>s are created by
tracing R functions. In general, when we want to convert some code into
another form, there are two approaches:</p>
<ol style="list-style-type: decimal">
<li>Static analysis, which would require operating on the abstract
syntax tree (AST) of the code.</li>
<li>Dynamic analysis (aka “tracing”), which executes the code and
records (selected) operations.</li>
</ol>
<p>The former approach is followed by the {quickr} package, which allows
you to transpile R code into Fortran. In {anvil}, we are following the
dynamic approach, which we will now illustrate. Our goal will be to
trace the following function, which either adds or subtracts two
tensors. The first two arguments are expected to be
<code>AnvilTensor</code>s, while the third is either <code>"add"</code>
or <code>"sub"</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-xla.github.io/anvil/" class="external-link">anvil</a></span><span class="op">)</span></span>
<span><span class="va">f</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">op</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">op</span> <span class="op">==</span> <span class="st">"add"</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/nv_binary_ops.html">nv_add</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">op</span> <span class="op">==</span> <span class="st">"sub"</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/nv_binary_ops.html">nv_sub</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"Unsupported operation"</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>To do this, we use <code><a href="../reference/trace_fn.html">anvil::trace_fn()</a></code>, which takes in an
<code>R</code> function and a list of example arguments that specify the
types of the inputs.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">1</span>, <span class="st">"f32"</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">5</span>, <span class="st">"f32"</span><span class="op">)</span></span>
<span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/trace_fn.html">trace_fn</a></span><span class="op">(</span><span class="va">f</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span>, op <span class="op">=</span> <span class="st">"add"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span></span></code></pre></div>
<pre><code><span><span class="co">## &lt;Graph&gt;</span></span>
<span><span class="co">##   Inputs:</span></span>
<span><span class="co">##     %x1: f32[]</span></span>
<span><span class="co">##     %x2: f32[]</span></span>
<span><span class="co">##   Body:</span></span>
<span><span class="co">##     %1: f32[] = add(%x1, %x2)</span></span>
<span><span class="co">##   Outputs:</span></span>
<span><span class="co">##     %1: f32[]</span></span></code></pre>
<p>The output of <code><a href="../reference/trace_fn.html">trace_fn()</a></code> is now a <code>Graph</code>
object that represents the computation. The fields of the
<code>Graph</code> are:</p>
<ul>
<li>
<code>inputs</code>, which are <code>GraphValue</code>s that
represent the inputs to the function.</li>
<li>
<code>outputs</code>, which are <code>GraphValue</code>s that
represent the outputs of the function.</li>
<li>
<code>calls</code>, which are <code>PrimitiveCall</code>s that take
in <code>GraphValue</code>s (and parameters) and produce output
<code>GraphValue</code>s.</li>
<li>
<code>in_tree</code>, <code>out_tree</code>, which we will cover
later (do we??)</li>
</ul>
<p>What happens internally in <code><a href="../reference/trace_fn.html">trace_fn()</a></code> is that a new
<code>GraphDescriptor</code> is created and the inputs <code>x</code>
and <code>y</code> are converted into <code>anvil::GraphBox</code>
objects. Then, the function <code>f</code> is simply evaluated with the
<code>GraphBox</code> objects as inputs. During this evaluation, we need
to distinguish between two cases:</p>
<ol style="list-style-type: decimal">
<li>A “standard” <code>R</code> function is called: Here, nothing
special happens and the function is simply evaluated.</li>
<li>An <code>anvil</code> function is called: Here, the operation that
underlies the function is recorded in the
<code>GraphDescriptor</code>.</li>
</ol>
<p>The evaluation of the <code>if</code> statement is an example for the
first category. Because we set <code>op = "add"</code>, only the first
branch is executed. Then, we are calling <code>nv_add</code>, which
attaches a <code>PrimitiveCall</code> that represents the addition of
the two tensors to the <code>@calls</code> of the
<code>GraphDescriptor</code>.</p>
<p>A <code>PrimitiveCall</code> object consists of the following
fields:</p>
<ul>
<li>
<code>primitive</code>: The primitive function that was called.</li>
<li>
<code>inputs</code>: The inputs to the primitive function.</li>
<li>
<code>params</code>: The parameters (non-tensors) to the primitive
function.</li>
<li>
<code>outputs</code>: The outputs of the primitive function.</li>
</ul>
<p>When the evaluation of <code>f</code> is complete, the
<code>@outputs</code> field of the <code>GraphDescriptor</code> is set
and the <code>Graph</code> is subsequently created from the
<code>GraphDescriptor</code>. The only difference between the
<code>Graph</code> and the <code>GraphDescriptor</code> is that the
latter has some utility fields that are useful during graph creation,
but for the purposes of this tutorial, you can think of them as being
the same.</p>
</div>
<div class="section level3">
<h3 id="transforming-graphs-into-other-graphs">Transforming Graphs into other Graphs<a class="anchor" aria-label="anchor" href="#transforming-graphs-into-other-graphs"></a>
</h3>
<p>Once we have staged out our <code>R</code> function into a simpler
format, we can do all sorts of things with it, e.g., compute its
gradient. The {anvil} package does not in any way dictate how such a
<code>Graph</code> to <code>Graph</code> transformation can be
implemented. For most interesting transformations, however, we need to
store some information for each {anvil} primitive function. In the case
of the gradient, we need to store the derivative rules. For this,
<code><a href="../reference/Primitive.html">anvil::Primitive</a></code> objects have a <code>@rules</code> field
that can be populated. The derivative rules are stored as functions
under the <code>"backward"</code> name.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">anvil</span><span class="fu">:::</span><span class="va">p_add</span><span class="op">@</span><span class="va">rules</span><span class="op">[[</span><span class="st">"backward"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## function (inputs, outputs, grads, .required) </span></span>
<span><span class="co">## {</span></span>
<span><span class="co">##     grad &lt;- grads[[1L]]</span></span>
<span><span class="co">##     list(if (.required[[1L]]) grad, if (.required[[2L]]) grad)</span></span>
<span><span class="co">## }</span></span>
<span><span class="co">## &lt;bytecode: 0x555f45046428&gt;</span></span>
<span><span class="co">## &lt;environment: namespace:anvil&gt;</span></span></code></pre>
<p>The <code>anvil:::transform_gradient</code> function uses these rules
to compute the gradient of a function. For this specific transformation,
we are walking the graph backwards and apply the derivative rules, which
will add the “backward pass” to the graph. Besides the forward graph,
the transformation takes in the <code>wrt</code> argument, which
specifies with respect to which arguments to compute the gradient.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bwd_graph</span> <span class="op">&lt;-</span> <span class="fu">anvil</span><span class="fu">:::</span><span class="fu">transform_gradient</span><span class="op">(</span><span class="va">graph</span>, wrt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x"</span>, <span class="st">"y"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">bwd_graph</span></span></code></pre></div>
<pre><code><span><span class="co">## &lt;Graph&gt;</span></span>
<span><span class="co">##   Inputs:</span></span>
<span><span class="co">##     %x1: f32[]</span></span>
<span><span class="co">##     %x2: f32[]</span></span>
<span><span class="co">##   Constants:</span></span>
<span><span class="co">##     %c1: f32[]</span></span>
<span><span class="co">##   Body:</span></span>
<span><span class="co">##     %1: f32[] = add(%x1, %x2)</span></span>
<span><span class="co">##   Outputs:</span></span>
<span><span class="co">##     %c1: f32[]</span></span>
<span><span class="co">##     %c1: f32[]</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="lowering-a-graph">Lowering a Graph<a class="anchor" aria-label="anchor" href="#lowering-a-graph"></a>
</h3>
<p>In order to execute a <code>Graph</code>, we need to convert it into
a – wait for it – executable. Currently, there is only one way to do
this, namely to convert the <code>Graph</code> into a
<code><a href="https://r-xla.github.io/stablehlo/reference/Func.html" class="external-link">stablehlo::Func</a></code> object and to then compile it via
<code><a href="https://r-xla.github.io/pjrt/reference/pjrt_compile.html" class="external-link">pjrt::pjrt_compile()</a></code>.</p>
<p>Like for the gradient transformation, the rules of how to do this
transformation are stored in the <code>@rules</code> fields of the
primitives.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">anvil</span><span class="fu">:::</span><span class="va">p_add</span><span class="op">@</span><span class="va">rules</span><span class="op">[[</span><span class="st">"stablehlo"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## function (lhs, rhs) </span></span>
<span><span class="co">## {</span></span>
<span><span class="co">##     list(stablehlo::hlo_add(lhs, rhs))</span></span>
<span><span class="co">## }</span></span>
<span><span class="co">## &lt;bytecode: 0x555f45045c10&gt;</span></span>
<span><span class="co">## &lt;environment: namespace:anvil&gt;</span></span></code></pre>
<p>They are applied in the <code><a href="../reference/stablehlo.html">anvil::stablehlo</a></code> function.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">func</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stablehlo.html">stablehlo</a></span><span class="op">(</span><span class="va">graph</span><span class="op">)</span><span class="op">[[</span><span class="fl">1L</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">func</span></span></code></pre></div>
<pre><code><span><span class="co">## func.func @main (%0: tensor&lt;f32&gt;, %1: tensor&lt;f32&gt;) -&gt; tensor&lt;f32&gt; {</span></span>
<span><span class="co">## %2 = "stablehlo.add" (%0, %1): (tensor&lt;f32&gt;, tensor&lt;f32&gt;) -&gt; (tensor&lt;f32&gt;)</span></span>
<span><span class="co">## "func.return"(%2): (tensor&lt;f32&gt;) -&gt; ()</span></span>
<span><span class="co">## }</span></span></code></pre>
<p>Now, we can compile the function via <code>pjrt_compile()</code>.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">hlo_str</span> <span class="op">&lt;-</span> <span class="fu">stablehlo</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/stablehlo/reference/repr.html" class="external-link">repr</a></span><span class="op">(</span><span class="va">func</span><span class="op">)</span></span>
<span><span class="va">program</span> <span class="op">&lt;-</span> <span class="fu">pjrt</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/pjrt/reference/pjrt_program.html" class="external-link">pjrt_program</a></span><span class="op">(</span>src <span class="op">=</span> <span class="va">hlo_str</span>, format <span class="op">=</span> <span class="st">"mlir"</span><span class="op">)</span></span>
<span><span class="va">exec</span> <span class="op">&lt;-</span> <span class="fu">pjrt</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/pjrt/reference/pjrt_compile.html" class="external-link">pjrt_compile</a></span><span class="op">(</span><span class="va">program</span><span class="op">)</span></span></code></pre></div>
<p>To run the function, we simply pass the tensors to the
executable.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">out</span> <span class="op">&lt;-</span> <span class="fu">pjrt</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/pjrt/reference/pjrt_execute.html" class="external-link">pjrt_execute</a></span><span class="op">(</span><span class="va">exec</span>, <span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span><span class="va">out</span></span></code></pre></div>
<pre><code><span><span class="co">## PJRTBuffer </span></span>
<span><span class="co">##  6.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="the-user-interface">The user interface<a class="anchor" aria-label="anchor" href="#the-user-interface"></a>
</h2>
<div class="section level3">
<h3 id="jit">jit<a class="anchor" aria-label="anchor" href="#jit"></a>
</h3>
<p>In the previous section, we have shown how the transformations are
implemented under the hood. The actual user interface is a little more
user-friendly and follows the <code>JAX</code> interface. We will start
by explaining <code><a href="../reference/jit.html">jit()</a></code>, where we mark the <code>op</code>
argument as <code>static</code>, i.e., it is not an
<code>AnvilTensor</code>.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">f_jit</span> <span class="op">&lt;-</span>  <span class="fu"><a href="../reference/jit.html">jit</a></span><span class="op">(</span><span class="va">f</span>, static <span class="op">=</span> <span class="st">"op"</span><span class="op">)</span></span>
<span><span class="fu">f_jit</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  6.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<p>It might be intuitive to think that <code><a href="../reference/jit.html">jit()</a></code> first calls
<code><a href="../reference/trace_fn.html">trace_fn()</a></code>, then runs <code><a href="../reference/stablehlo.html">stablehlo()</a></code>, followed by
<code>pjrt_compile()</code>. This is, however, not what is happening,
because for all of this, we need example inputs to the function. The
function <code>f_jit</code> should instead be seen as a recipe to do all
of this Just In Time (JIT).</p>
<p>However, if we were to apply these steps every time the
<code>f_jit</code> function is called, this would be very inefficient,
because tracing and compiling takes some time. Therefore, the function
<code>f_jit</code> also contains a cache (implemented as an
<code><a href="https://rdrr.io/pkg/xlamisc/man/LRUCache.html" class="external-link">xlamisc::LRUCache</a></code>), which will check whether there is
already an executable for the given inputs. For this, the types of all
<code>AnvilTensor</code>s need to match exactly (data type and shape)
and all static arguments need to be identical. For example, if we run
the function with <code>AnvilTensor</code>s of the same type, but
different values, the function won’t be recompiled, which we can see by
checking the size of the cache:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cache_size</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">f</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/environment.html" class="external-link">environment</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span><span class="op">$</span><span class="va">cache</span><span class="op">$</span><span class="va">size</span></span>
<span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1</span></span></code></pre>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">f_jit</span><span class="op">(</span><span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="op">-</span><span class="fl">99</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">2</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  -97.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1</span></span></code></pre>
<p>When we execute the function with tensors of different
<code>dtype</code> or <code>shape</code>, the function will be
recompiled:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">f_jit</span><span class="op">(</span><span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">1</span>, <span class="st">"i32"</span><span class="op">)</span>, <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">2</span>, <span class="st">"i32"</span><span class="op">)</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  3</span></span>
<span><span class="co">## [ CPUi32{} ]</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 2</span></span></code></pre>
<p>Also, if we provide different values for static arguments, the
function will be recompiled:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">f_jit</span><span class="op">(</span><span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">1</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">2</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="st">"sub"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  -1.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 3</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="gradient">gradient<a class="anchor" aria-label="anchor" href="#gradient"></a>
</h3>
<p>Just like <code><a href="../reference/jit.html">jit()</a></code>, <code><a href="../reference/gradient.html">gradient()</a></code> also returns a
function that will lazily create the graph and transform it, once the
inputs are provided.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gradient.html">gradient</a></span><span class="op">(</span><span class="va">f</span>, wrt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x"</span>, <span class="st">"y"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>However, the output <code>g()</code> cannot be called on
<code>AnvilTensor</code>s, because it is just a graph building
function.</p>
<p>In order to execute it, we need to wrap it in a <code><a href="../reference/jit.html">jit()</a></code>
call:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g_jit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/jit.html">jit</a></span><span class="op">(</span><span class="va">g</span>, static <span class="op">=</span> <span class="st">"op"</span><span class="op">)</span></span>
<span><span class="fu">g_jit</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $x</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  1.0000</span></span>
<span><span class="co">## [ CPUf32{} ] </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $y</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  1.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<p>Moreover, we can also use <code>g()</code> in another function:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">h</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nv_binary_ops.html">nv_add</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span>  <span class="fu">g</span><span class="op">(</span><span class="va">z</span>, <span class="va">z</span>, <span class="st">"add"</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">h_jit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/jit.html">jit</a></span><span class="op">(</span><span class="va">h</span><span class="op">)</span></span>
<span><span class="fu">h_jit</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $x</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  2.0000</span></span>
<span><span class="co">## [ CPUf32{} ] </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $y</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  2.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<p>So, what is happening here? Once the inputs <code>x</code> and
<code>y</code> are provided to <code>h_jit</code>, a new
<code>GraphDescriptor</code> is created and the inputs <code>x</code>
and <code>y</code> are converted into <code>GraphBox</code> objects.
Then, we record the addition of <code>x</code> and <code>y</code> in the
<code>GraphDescriptor</code>. When we are then calling into
<code>g</code>, a second <code>GraphDescriptor</code> is created, where
we will first build up the <code>Graph</code> representing the
<code>g</code> function. After we are done doing this, we transform this
graph into its gradient graph. Once this is done, the sub-graph is
inlined into the parent graph (that so far only holds the addition of
<code>x</code> and <code>y</code>). We can look at this graph below:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">h_graph</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/trace_fn.html">trace_fn</a></span><span class="op">(</span><span class="va">h</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>After that, this graph is lowered to stablehlo and subsequently
compiled.</p>
</div>
</div>
<div class="section level2">
<h2 id="more-internals">More Internals<a class="anchor" aria-label="anchor" href="#more-internals"></a>
</h2>
<div class="section level3">
<h3 id="constant-handling">Constant Handling<a class="anchor" aria-label="anchor" href="#constant-handling"></a>
</h3>
</div>
<div class="section level3">
<h3 id="nested-inputs-and-outputs">Nested Inputs and Outputs<a class="anchor" aria-label="anchor" href="#nested-inputs-and-outputs"></a>
</h3>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Sebastian Fischer, Daniel Falbel, Nikolai German.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
