<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Internals • anvil</title>
<!-- mathjax math --><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script><script>
  window.MathJax = {
    chtml: {
      fontURL: "https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/output/chtml/fonts/woff-v2"
    }
  };
</script><script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Internals">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">anvil</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/anvil.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/anvil.html">Get Started</a></li>
    <li><a class="dropdown-item" href="../articles/random-numbers.html">Random Number Generation</a></li>
    <li><a class="dropdown-item" href="../articles/type-promotion.html">Type Promotion</a></li>
    <li><a class="dropdown-item" href="../articles/primitives.html">Primitives Overview</a></li>
    <li><a class="dropdown-item" href="../articles/debugging.html">Debugging</a></li>
  </ul>
</li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-technical" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Technical</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-technical">
<li><a class="dropdown-item" href="../articles/internals.html">Internals</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-xla/anvil/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Internals</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/r-xla/anvil/blob/quickr/vignettes/internals.Rmd" class="external-link"><code>vignettes/internals.Rmd</code></a></small>
      <div class="d-none name"><code>internals.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="transforming-code">Transforming Code<a class="anchor" aria-label="anchor" href="#transforming-code"></a>
</h2>
<p>While a real anvil is made for reshaping metal, this package is a
tool for reshaping code. We refer to such a rewriting of code as a
<strong>transformation</strong>, of which there are three types:</p>
<ol style="list-style-type: decimal">
<li>
<code>R</code> <span class="math inline">\(\rightarrow\)</span>
<code>Graph</code>: Generic <code>R</code> functions are too complicated
to handle, so the first step in {anvil} is always to convert them into a
computational <code><a href="../reference/Graph.html">anvil::Graph</a></code> object via
<strong>tracing</strong>. Such a <code>Graph</code> is similar to
<code>JAXExpr</code> objects in <code>JAX</code>. It operates only on
<code>AnvilTensor</code> objects and applies
<code><a href="../reference/Primitive.html">anvil::Primitive</a></code> operations to them.</li>
<li>
<code>Graph</code> <span class="math inline">\(\rightarrow\)</span>
<code>Graph</code>: It is possible to transform <code>Graph</code>s into
other <code>Graph</code>s. Their purpose is to change the functionality
of the code. At the time of writing, there is essentially only one such
transformation, namely backward-mode automatic differentiation via
<code><a href="../reference/gradient.html">gradient()</a></code>.</li>
<li>
<code>Graph</code> <span class="math inline">\(\rightarrow\)</span>
<code>Executable</code>: In order to perform the actual computation, the
<code>Graph</code> needs to be converted into an executable. Currently,
we only support the XLA backend (via <code>stablehlo</code> and
<code>pjrt</code>), but we are working on an experimental <a href="https://github.com/t-kalinowski/quickr" class="external-link">quickr</a> backend.</li>
</ol>
<div class="section level3">
<h3 id="tracing-r-functions-into-graphs">Tracing R Functions into Graphs<a class="anchor" aria-label="anchor" href="#tracing-r-functions-into-graphs"></a>
</h3>
<p>All functionality in the {anvil} package is centered around the
<code><a href="../reference/Graph.html">anvil::Graph</a></code> class. While it is in principle possible to
create <code>Graph</code>s by hand, these are usually created by tracing
R functions. In general, when we want to convert some code into another
form (in our case, R Code into a <code>Graph</code>), there are two
approaches:</p>
<ol style="list-style-type: decimal">
<li>Static analysis, which would require operating on the abstract
syntax tree (AST) of the code.</li>
<li>Dynamic analysis (aka “tracing”), which executes the code and
records selected operations.</li>
</ol>
<p>The former approach is followed by the {quickr} package, while we go
with tracing. We start with a simple, yet illustrative example that
either adds or multiplies two inputs <code>x</code> and <code>y</code>
depending on the value of <code>op</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-xla.github.io/anvil/" class="external-link">anvil</a></span><span class="op">)</span></span>
<span><span class="va">f</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="va">op</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">op</span> <span class="op">==</span> <span class="st">"add"</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/nv_add.html">nv_add</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">op</span> <span class="op">==</span> <span class="st">"mul"</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="../reference/nv_mul.html">nv_mul</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="kw"><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop</a></span><span class="op">(</span><span class="st">"Unsupported operation"</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>To do this, we use <code><a href="../reference/trace_fn.html">anvil::trace_fn()</a></code>, which takes in an
<code>R</code> function and a list of <code>AbstractTensor</code> inputs
that specify the types of the inputs.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">aten</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/AbstractTensor.html">nv_aten</a></span><span class="op">(</span><span class="st">"f32"</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">aten</span></span></code></pre></div>
<pre><code><span><span class="co">## AbstractTensor(dtype=f32, shape=)</span></span></code></pre>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/trace_fn.html">trace_fn</a></span><span class="op">(</span><span class="va">f</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">aten</span>, y <span class="op">=</span> <span class="va">aten</span>, op <span class="op">=</span> <span class="st">"mul"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span></span></code></pre></div>
<pre><code><span><span class="co">## &lt;Graph&gt;</span></span>
<span><span class="co">##   Inputs:</span></span>
<span><span class="co">##     %x1: f32[]</span></span>
<span><span class="co">##     %x2: f32[]</span></span>
<span><span class="co">##   Body:</span></span>
<span><span class="co">##     %1: f32[] = mul(%x1, %x2)</span></span>
<span><span class="co">##   Outputs:</span></span>
<span><span class="co">##     %1: f32[]</span></span></code></pre>
<p>The output of <code><a href="../reference/trace_fn.html">trace_fn()</a></code> is now a <code>Graph</code>
object that represents the computation. The fields of the
<code>Graph</code> are:</p>
<ul>
<li>
<code>inputs</code>, which are <code>GraphNode</code>s that
represent the inputs to the function.</li>
<li>
<code>outputs</code>, which are <code>GraphNode</code>s that
represent the outputs of the function.</li>
<li>
<code>calls</code>, which are <code>PrimitiveCall</code>s that take
in <code>GraphNode</code>s (and parameters) and produce output
<code>GraphNode</code>s.</li>
<li>
<code>in_tree</code>, <code>out_tree</code>, which we will cover
later (do we??)</li>
</ul>
<p>During <code>trace_fn</code>, the inputs What happens during
<code><a href="../reference/trace_fn.html">trace_fn()</a></code> is that a new <code>GraphDescriptor</code> is
created and the inputs <code>x</code> and <code>y</code> are converted
into <code><a href="../reference/GraphBox.html">anvil::GraphBox</a></code> objects. Then, the function
<code>f</code> is simply evaluated with the <code>GraphBox</code>
objects as inputs. During this evaluation, we need to distinguish
between two cases:</p>
<ol style="list-style-type: decimal">
<li>A “standard” <code>R</code> function is called: Here, nothing
special happens and the function is simply evaluated.</li>
<li>An <code>anvil</code> function is called: Here, the operation that
underlies the function is recorded in the
<code>GraphDescriptor</code>.</li>
</ol>
<p>The evaluation of the <code>if</code> statement is an example for the
first category. Because we set <code>op = "mul"</code>, only the first
branch is executed. Then, we are calling <code>nv_mul</code>, which
attaches a <code>PrimitiveCall</code> that represents the multiplication
of the two tensors to the <code>@calls</code> of the
<code>GraphDescriptor</code>. Note that the <code>nv_mul</code> is
itself not primitive, but performs some type promotion and broadcasting
if needed, before calling into the primitive <code><a href="../reference/nvl_mul.html">nvl_mul()</a></code>.</p>
<p>A <code>PrimitiveCall</code> object consists of the following
fields:</p>
<ul>
<li>
<code>primitive</code>: The primitive function that was called.</li>
<li>
<code>inputs</code>: The inputs to the primitive function.</li>
<li>
<code>params</code>: The parameters (non-tensors) to the primitive
function.</li>
<li>
<code>outputs</code>: The outputs of the primitive function.</li>
</ul>
<p>When the evaluation of <code>f</code> is complete, the
<code>@outputs</code> field of the <code>GraphDescriptor</code> is set
and the <code>Graph</code> is subsequently created from the
<code>GraphDescriptor</code>. The only difference between the
<code>Graph</code> and the <code>GraphDescriptor</code> is that the
latter has some utility fields that are useful during graph creation,
but for the purposes of this tutorial, you can think of them as being
the same.</p>
</div>
<div class="section level3">
<h3 id="transforming-graphs-into-other-graphs">Transforming Graphs into other Graphs<a class="anchor" aria-label="anchor" href="#transforming-graphs-into-other-graphs"></a>
</h3>
<p>Once the <code>R</code> function is staged out into a simpler format,
it is ready to be transformed. The {anvil} package does not in any way
dictate how such a <code>Graph</code> to <code>Graph</code>
transformation can be implemented. For most interesting transformations,
however, we need to store some information for each {anvil} primitive
function. In the case of the gradient, we need to store the derivative
rules. For this, <code><a href="../reference/Primitive.html">anvil::Primitive</a></code> objects have a
<code>@rules</code> field that can be populated. The derivative rules
are stored as functions under the <code>"backward"</code> name. We can
access a primitive by it’s name via the <code><a href="../reference/prim.html">prim()</a></code>
function:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/prim.html">prim</a></span><span class="op">(</span><span class="st">"mul"</span><span class="op">)</span><span class="op">@</span><span class="va">rules</span><span class="op">[[</span><span class="st">"backward"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## function (inputs, outputs, grads, .required) </span></span>
<span><span class="co">## {</span></span>
<span><span class="co">##     lhs &lt;- inputs[[1L]]</span></span>
<span><span class="co">##     rhs &lt;- inputs[[2L]]</span></span>
<span><span class="co">##     grad &lt;- grads[[1L]]</span></span>
<span><span class="co">##     list(if (.required[[1L]]) nvl_mul(grad, rhs), if (.required[[2L]]) nvl_mul(grad, </span></span>
<span><span class="co">##         lhs))</span></span>
<span><span class="co">## }</span></span>
<span><span class="co">## &lt;bytecode: 0x5559631244e0&gt;</span></span>
<span><span class="co">## &lt;environment: namespace:anvil&gt;</span></span></code></pre>
<p>The <code><a href="../reference/transform_gradient.html">anvil::transform_gradient</a></code> function uses these rules
to compute the gradient of a function. For this specific transformation,
we are walking the graph backwards and apply the derivative rules, which
will append the “backward pass” to the graph. Besides the forward graph,
the transformation takes in the <code>wrt</code> argument, which
specifies with respect to which arguments to compute the gradient.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bwd_graph</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/transform_gradient.html">transform_gradient</a></span><span class="op">(</span><span class="va">graph</span>, wrt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x"</span>, <span class="st">"y"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">bwd_graph</span></span></code></pre></div>
<pre><code><span><span class="co">## &lt;Graph&gt;</span></span>
<span><span class="co">##   Inputs:</span></span>
<span><span class="co">##     %x1: f32[]</span></span>
<span><span class="co">##     %x2: f32[]</span></span>
<span><span class="co">##   Constants:</span></span>
<span><span class="co">##     %c1: f32[]</span></span>
<span><span class="co">##   Body:</span></span>
<span><span class="co">##     %1: f32[] = mul(%x1, %x2)</span></span>
<span><span class="co">##     %2: f32[] = mul(%c1, %x2)</span></span>
<span><span class="co">##     %3: f32[] = mul(%c1, %x1)</span></span>
<span><span class="co">##   Outputs:</span></span>
<span><span class="co">##     %2: f32[]</span></span>
<span><span class="co">##     %3: f32[]</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="lowering-a-graph">Lowering a Graph<a class="anchor" aria-label="anchor" href="#lowering-a-graph"></a>
</h3>
<p>In order to execute a <code>Graph</code>, we need to convert it into
a – wait for it – executable. Here, we should how to compile using the
XLA backend. First, we will translate the <code>Graph</code> into the
StableHLO representation via the {stablehlo} package. Then, we will
compile this program using the XLA compiler that is accessible via the
{pjrt} package.</p>
<p>Like for the gradient transformation, the rules of how to do this
transformation are stored in the <code>@rules</code> fields of the
primitives.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/prim.html">prim</a></span><span class="op">(</span><span class="st">"mul"</span><span class="op">)</span><span class="op">@</span><span class="va">rules</span><span class="op">[[</span><span class="st">"stablehlo"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## function (lhs, rhs) </span></span>
<span><span class="co">## {</span></span>
<span><span class="co">##     list(stablehlo::hlo_multiply(lhs, rhs))</span></span>
<span><span class="co">## }</span></span>
<span><span class="co">## &lt;bytecode: 0x555963123638&gt;</span></span>
<span><span class="co">## &lt;environment: namespace:anvil&gt;</span></span></code></pre>
<p>The <code><a href="../reference/stablehlo.html">anvil::stablehlo</a></code> function will create a
<code><a href="https://r-xla.github.io/stablehlo/reference/Func.html" class="external-link">stablehlo::Func</a></code> object and will sequentially translate the
<code>PrimitiveCall</code>s into StableHLO operations.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">func</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stablehlo.html">stablehlo</a></span><span class="op">(</span><span class="va">graph</span><span class="op">)</span><span class="op">[[</span><span class="fl">1L</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">func</span></span></code></pre></div>
<pre><code><span><span class="co">## func.func @main (%0: tensor&lt;f32&gt;, %1: tensor&lt;f32&gt;) -&gt; tensor&lt;f32&gt; {</span></span>
<span><span class="co">## %2 = "stablehlo.multiply" (%0, %1): (tensor&lt;f32&gt;, tensor&lt;f32&gt;) -&gt; (tensor&lt;f32&gt;)</span></span>
<span><span class="co">## "func.return"(%2): (tensor&lt;f32&gt;) -&gt; ()</span></span>
<span><span class="co">## }</span></span></code></pre>
<p>Now, we can compile the function via <code>pjrt_compile()</code>.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">hlo_str</span> <span class="op">&lt;-</span> <span class="fu">stablehlo</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/stablehlo/reference/repr.html" class="external-link">repr</a></span><span class="op">(</span><span class="va">func</span><span class="op">)</span></span>
<span><span class="va">program</span> <span class="op">&lt;-</span> <span class="fu">pjrt</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/pjrt/reference/pjrt_program.html" class="external-link">pjrt_program</a></span><span class="op">(</span>src <span class="op">=</span> <span class="va">hlo_str</span>, format <span class="op">=</span> <span class="st">"mlir"</span><span class="op">)</span></span>
<span><span class="va">exec</span> <span class="op">&lt;-</span> <span class="fu">pjrt</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/pjrt/reference/pjrt_compile.html" class="external-link">pjrt_compile</a></span><span class="op">(</span><span class="va">program</span><span class="op">)</span></span></code></pre></div>
<p>To run the function, we simply pass the tensors to the executable,
which will output a <code>PJRTBuffer</code> that we can easily convert
to an <code>AnvilTensor</code>.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">3</span>, <span class="st">"f32"</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">4</span>, <span class="st">"f32"</span><span class="op">)</span></span>
<span><span class="va">out</span> <span class="op">&lt;-</span> <span class="fu">pjrt</span><span class="fu">::</span><span class="fu"><a href="https://r-xla.github.io/pjrt/reference/pjrt_execute.html" class="external-link">pjrt_execute</a></span><span class="op">(</span><span class="va">exec</span>, <span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span><span class="va">out</span></span></code></pre></div>
<pre><code><span><span class="co">## PJRTBuffer </span></span>
<span><span class="co">##  12.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/nv_tensor.html">nv_tensor</a></span><span class="op">(</span><span class="va">out</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  12.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="the-user-interface">The User Interface<a class="anchor" aria-label="anchor" href="#the-user-interface"></a>
</h2>
<p>In the previous section, we have shown how the transformations are
implemented under the hood. The actual user interface is a little more
convenient and follows the <code>JAX</code> interface.</p>
<div class="section level3">
<h3 id="jit">
<code>jit()</code><a class="anchor" aria-label="anchor" href="#jit"></a>
</h3>
<p>The <code><a href="../reference/jit.html">jit()</a></code> function allows to convert a regular
<code>R</code> function into a Just-In-Time compiled function that can
be executed on <code>AnvilTensor</code>s. We apply it to our simple
example function, where we mark the non-tensor parameter <code>op</code>
as “static”. This means that the value of this parameter needs to be
known at compile time.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">f_jit</span> <span class="op">&lt;-</span>  <span class="fu"><a href="../reference/jit.html">jit</a></span><span class="op">(</span><span class="va">f</span>, static <span class="op">=</span> <span class="st">"op"</span><span class="op">)</span></span>
<span><span class="fu">f_jit</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  7.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<p>One might think that <code><a href="../reference/jit.html">jit()</a></code> first calls
<code><a href="../reference/trace_fn.html">trace_fn()</a></code>, then runs <code><a href="../reference/stablehlo.html">stablehlo()</a></code>, followed by
<code>pjrt_compile()</code>. This is, however, not what is happening, as
this requires the input types to be known. Instead, <code>f_jit</code>
is a “lazy” function that will only perform these steps once the inputs
are provided. However, if those steps were applied every time the
<code>f_jit</code> function is called, this would be very inefficient,
because tracing and compiling takes some time. Therefore, the function
<code>f_jit</code> also contains a cache (implemented as an
<code><a href="https://rdrr.io/pkg/xlamisc/man/LRUCache.html" class="external-link">xlamisc::LRUCache</a></code>), which will check whether there is
already a compiled executable for the given inputs. For this, the types
of all <code>AnvilTensor</code>s need to match exactly (data type and
shape) and all static arguments need to be identical. For example, if we
run the function with <code>AnvilTensor</code>s of the same type, but
different values, the function won’t be recompiled, which we can see by
checking the size of the cache, which is already 1, because we have
called it on <code>x</code> and <code>y</code> above.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cache_size</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">f</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/environment.html" class="external-link">environment</a></span><span class="op">(</span><span class="va">f</span><span class="op">)</span><span class="op">$</span><span class="va">cache</span><span class="op">$</span><span class="va">size</span></span>
<span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1</span></span></code></pre>
<p>After calling it with tensors of the same types and identical static
argument values, the size of the cache remains 1:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">f_jit</span><span class="op">(</span><span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="op">-</span><span class="fl">99</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">2</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  -97.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1</span></span></code></pre>
<p>When we execute the function with tensors of different
<code>dtype</code> or <code>shape</code>, the function will be
recompiled:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">f_jit</span><span class="op">(</span><span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">1</span>, <span class="st">"i32"</span><span class="op">)</span>, <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">2</span>, <span class="st">"i32"</span><span class="op">)</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  3</span></span>
<span><span class="co">## [ CPUi32{} ]</span></span></code></pre>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 2</span></span></code></pre>
<p>Also, if we provide different values for static arguments, the
function will be recompiled:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">f_jit</span><span class="op">(</span><span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">1</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="fu"><a href="../reference/nv_tensor.html">nv_scalar</a></span><span class="op">(</span><span class="fl">2</span>, <span class="st">"f32"</span><span class="op">)</span>, <span class="st">"mul"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  2.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">cache_size</span><span class="op">(</span><span class="va">f_jit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 3</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="gradient">
<code>gradient()</code><a class="anchor" aria-label="anchor" href="#gradient"></a>
</h3>
<p>Just like <code><a href="../reference/jit.html">jit()</a></code>, <code><a href="../reference/gradient.html">gradient()</a></code> also returns a
function that will lazily create the graph and transform it, once the
inputs are provided.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gradient.html">gradient</a></span><span class="op">(</span><span class="va">f</span>, wrt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x"</span>, <span class="st">"y"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Calling <code>g()</code> on <code>AnvilTensor</code>s will not
actually compute the gradient, but instead just output the output types,
c.f. the <a href="debugging.html">debugging vignette</a> for more.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">g</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $x</span></span>
<span><span class="co">##  1.0000</span></span>
<span><span class="co">## [ CPUf32{} ] </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $y</span></span>
<span><span class="co">##  1.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<p>If we want to actually compute the gradient, we need to wrap it in
<code><a href="../reference/jit.html">jit()</a></code>.</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">g_jit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/jit.html">jit</a></span><span class="op">(</span><span class="va">g</span>, static <span class="op">=</span> <span class="st">"op"</span><span class="op">)</span></span>
<span><span class="fu">g_jit</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span>, <span class="st">"add"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $x</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  1.0000</span></span>
<span><span class="co">## [ CPUf32{} ] </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $y</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  1.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<p>Moreover, we can also use <code>g</code> in another function:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">h</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">z</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/nv_add.html">nv_add</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span>  <span class="fu">g</span><span class="op">(</span><span class="va">z</span>, <span class="va">x</span>, <span class="st">"mul"</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">h_jit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/jit.html">jit</a></span><span class="op">(</span><span class="va">h</span><span class="op">)</span></span>
<span><span class="fu">h_jit</span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $x</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  3.0000</span></span>
<span><span class="co">## [ CPUf32{} ] </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $y</span></span>
<span><span class="co">## AnvilTensor </span></span>
<span><span class="co">##  7.0000</span></span>
<span><span class="co">## [ CPUf32{} ]</span></span></code></pre>
<p>So, what is happening here? Once the inputs <code>x</code> and
<code>y</code> are provided to <code>h_jit</code>, a new
<code>GraphDescriptor</code> is created and the inputs <code>x</code>
and <code>y</code> are converted into <code>GraphBox</code> objects.
Then, the addition of <code>x</code> and <code>y</code> is recorded in
the <code>GraphDescriptor</code>. The call into <code>g()</code> is a
bit more involved. First, a new <code>GraphDescriptor</code> is created
and the forward computation of <code>g</code> is recorded. Subsequently,
the backward pass will be added to the descriptor, after which it will
be converted into a <code>Graph</code>. This <code>Graph</code> will
then be inlined into the parent <code>GraphDescriptor</code>
(representing the whole function <code>h</code>), which is then
converted into the main <code>Graph</code>. We can look at this graph
below, where <code>trace_fn</code> internally converts the
<code>AnvilTensor</code>s <code>x</code> and <code>y</code> into their
abstract representation.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">h_graph</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/trace_fn.html">trace_fn</a></span><span class="op">(</span><span class="va">h</span>, <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">h_graph</span></span></code></pre></div>
<pre><code><span><span class="co">## &lt;Graph&gt;</span></span>
<span><span class="co">##   Inputs:</span></span>
<span><span class="co">##     %x1: f32[]</span></span>
<span><span class="co">##     %x2: f32[]</span></span>
<span><span class="co">##   Constants:</span></span>
<span><span class="co">##     %c1: f32[]</span></span>
<span><span class="co">##   Body:</span></span>
<span><span class="co">##     %1: f32[] = add(%x1, %x2)</span></span>
<span><span class="co">##     %2: f32[] = mul(%1, %x1)</span></span>
<span><span class="co">##     %3: f32[] = mul(%c1, %x1)</span></span>
<span><span class="co">##     %4: f32[] = mul(%c1, %1)</span></span>
<span><span class="co">##   Outputs:</span></span>
<span><span class="co">##     %3: f32[]</span></span>
<span><span class="co">##     %4: f32[]</span></span></code></pre>
<p>Afterwards, this graph is lowered to stableHLO and subsequently
compiled.</p>
</div>
</div>
<div class="section level2">
<h2 id="more-internals">More Internals<a class="anchor" aria-label="anchor" href="#more-internals"></a>
</h2>
<div class="section level3">
<h3 id="debug-mode">Debug Mode<a class="anchor" aria-label="anchor" href="#debug-mode"></a>
</h3>
<p>For how to use debug mode, see the <a href="debugging.html">debugging
vignette</a>.</p>
<p>Debug-mode is different from jit-mode, because we don’t have a
context that can initialize a main <code>GraphDescriptor</code>. For
this reason, every primitive initializes its own
<code>GraphDescriptor</code> that is thrown away after the primitive
returns <code>DebugBox</code> objects. These <code>DebugBox</code>
objects are only for user-interaction and have a nice printer. Whenever
a primitive is evaluated, this <code>DebugBox</code> is converted to a
<code>GraphBox</code> object that is used for the actual evaluation via
<code>maybe_box_variable</code>. This ensures that we don’t have to
duplicate any evaluation logic as we the graph-building functions only
have to work with <code>GraphBox</code> objects.</p>
<p>What gets lost in debug mode is identity of values, because the
<code>GraphDescriptor</code> is thrown away. This means that we cannot
say anything about identity of values, only about their types.</p>
<p>Unfortunately, our current mode for detecting debug mode is whether a
<code>GraphDescriptor</code> is active. For this reason, we don’t allow
calling <code><a href="../reference/local_descriptor.html">local_descriptor()</a></code> in the global environment. Maybe
we can improve this in the future, but for now it seems to work.</p>
</div>
<div class="section level3">
<h3 id="constant-handling">Constant Handling<a class="anchor" aria-label="anchor" href="#constant-handling"></a>
</h3>
</div>
<div class="section level3">
<h3 id="nested-inputs-and-outputs">Nested Inputs and Outputs<a class="anchor" aria-label="anchor" href="#nested-inputs-and-outputs"></a>
</h3>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Sebastian Fischer, Daniel Falbel, Nikolai German.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
